[{"body":" What is Charles? CharlesCD is an open-source tool that makes deployments more agile, continuous, and safe, which allows development teams to perform hypothesis validations with a specific group of users, simultaneously.\nThe product brings a new concept to the community: the deployment in circles of users on Kubernetes clusters.  This kind of deployment makes it possible to create a segment with your clients' specific characteristics and, at the same time, submit several versions of the same application to test this circle of users.\nHow was the project created? Charles was created to offer a more efficient solution for the community to create deployments and test hypotheses together, which allows the identification of errors and the execution of possible solutions to solve bugs faster.\nThe concept behind the tool goes back to the theory proposed by the biologist Charles Darwin (1809-1882), in which evolution goes by the adaptation to a new environment. In the development scenario, this evolution goes by constant improvements on the applications to build and test hypothesis in order to implement more reliable releases.\nFor this reason, we believe CharlesCD is the darwinism’s application inside the development and programming world.\nWhat does Charles do? The methodology implemented by Charles brings a lot of advantages such as:\n Simple segmentation of users based on their profiles or demographic data; Easy and sophisticated creation of implementation strategies using circles; Easy version management, allowing multiple parallel releases of the same application in the production environment; Monitoring the impact of each version through predefined metrics during the implementation creation.  Requirements In order to user Charles, it is necessary to fulfill some requirements:\n Installation: see what you need in the installation section. To make the tool work properly, you will need:   A Registry where the images of your application are stored. Define a CI flow. It is expected that this flow is active through a trigger, for example, a branch name that has a defined prefix. Besides that, the pipeline must build the application’s image and upload it to the registry mentioned before. Prepare the Helm template of your applications. This is important, a configured CD through Charles will need this information to make the deployments of your application.  System architecture The platform was built using a microservice approach, and it has the following modules:\n charlescd-ui: mirrors on the front-end the workspace configuration, users, modules, hypothesis, and boards. It is the platform graphical interface. charles-moove: manages workspaces, users, modules, hypothesis, and boards. It is the whole platform structure. charles-butler: orchestrates and manages releases and deploys. charles-circle-matcher: manages all created circles, and points out which circle each user belongs to, based on their characteristics. charlescd-compass: data providers integration, make metrics analysis and execute configurable actions. charlescd-hermes: notifies external services previously subscribed of deploy and undeploy events. charlescd-gate: control users' permissions according to the resources available in Charles' APIs.  ","excerpt":" What is Charles? CharlesCD is an open-source tool that makes …","ref":"/overview/","title":"Overview"},{"body":" O que é o Charles? O Charles é uma ferramenta open source que realiza deploys de forma ágil, contínua e segura, permitindo que as equipes de desenvolvimento realizem simultaneamente validações de hipóteses com grupos específicos de usuários.\nO produto traz um conceito pioneiro no mercado e na comunidade: deploys em círculos de usuários em clusters de Kubernetes.  Neste modelo de deploy, é possível segmentar seus clientes através de características específicas e, ao mesmo tempo, submeter diversas versões de uma mesma aplicação para teste com os usuários dos círculos.\nComo nasceu o produto? O Charles surgiu da necessidade de oferecer para a comunidade uma solução mais eficaz no trabalho de fazer deploys e testar hipóteses simultaneamente, permitindo mais rapidez na identificação de erros e execução de possíveis soluções para resolver os bugs.\nO conceito por trás da ferramenta remete à teoria proposta pelo biólogo Charles Darwin (1809-1882), ou seja, a de que a evolução se dá pela adaptação a um novo ambiente. No caso do desenvolvimento, essa evolução se dá através de constantes melhorias nas aplicações ao construir e testar hipóteses de maneira a implantar as releases mais precisas e eficazes.\nPor esse motivo, consideramos que o Charles é a aplicação do darwinismo dentro do universo de desenvolvimento e programação.\nO que o Charles faz? A metodologia implementada pelo Charles traz várias vantagens, como:\n Simples segmentação de usuários com base em seu perfil ou até mesmo dados demográficos; Criação de estratégias de implantação de maneira mais fácil e sofisticada utilizando os círculos; Fácil gerenciamento de versões em caso de múltiplas releases em paralelo no ambiente produtivo; Monitoramento dos impactos de cada versão através de métricas definidas durante a criação da implantação.  Requisitos Para utilizar o Charles, é preciso cumprir alguns pré-requisitos:\n Instalação: veja o que é necessário na seção de instalação. Para o funcionamento completo da ferramenta é preciso:   Possuir um Registry onde as imagens das suas aplicações são armazenadas. Definir um fluxo de CI. É esperado que esse fluxo seja ativado por meio de algum gatilho, por exemplo, um nome de branch que tenha um prefixo definido. Além disso, o pipeline deve realizar a construção da imagem da aplicação e o envio da mesma para o registry citado anteriormente. Elaborar o Helm template das suas aplicações. Isso é importante, porque o CD configurado por meio do Charles necessitará dessa informação para realizar o deploy da sua aplicação.  Arquitetura do sistema A plataforma foi construída utilizando a abordagem de microsserviços e possui os seguintes módulos:\n  charlescd-ui: responsável por prover uma interface de fácil usabilidade para todas as features fornecida pelo CharlesCD, no intuito de simplificar testes de hipóteses e circle deployment.\n  charlescd-moove: é um serviço backend que orquestra os testes de hipóteses de seus produtos e o pipeline de entrega até atingir seus círculos, facilitando a ponte entre Butler, Villager e Circle Matcher.\n  charlescd-butler: responsável por orquestrar e gerenciar as releases e deploys realizados.\n  charlescd-circle-matcher: gerencia todos os círculos criados, além de indicar a qual círculo um usuário pertence, com base em um conjunto de características.\n  charlescd-compass: integração do provedor de dados, faz análise de métricas e executa ações configuráveis.\n  charlescd-hermes: responsável por gerenciar e notificar eventos de webhook.\n  charlescd-gate: controla as permissões dos usuários em relação aos recursos existentes nas APIs do Charles.\n  ","excerpt":" O que é o Charles? O Charles é uma ferramenta open source que realiza …","ref":"/pt/overview/","title":"Overview"},{"body":" Circles Circles are groups of users created from specific characteristics, inside the same environment on Charles' platform. The developer is able to segment users according to the rules “AND/OR” which will make more sense to test that release later.\nFor example, it is possible to create a circle of engineers from the north of Brazil, another one from the southeast, and the third one with all Brazilian engineers. Based on the client’s segmentation, it is possible to make a variety of deployment logic.\nCircle Matcher It is an HTTP service that allows you to identify which segmentation the user belongs to, based on predefined logic rules. For that, Circle Matcher receives a JSON request with the user’s attributes and also the circle identifier of which group user belongs.\nComponents Components are part of the modules you create on Charles. They work as an application abstraction, which means that they have their own configuration and every part of it belongs to a module application you are working on it.\nOpen Sea This term was originated with Charles and refers to a default segmentation that will be used for all users not linked to any circle.\nFor example, if you add 300 users to your database and don’t specify which segmentation you want to direct your hypothesis, Charles will redirect it to all, that is when your hypothesis will fall into the open sea.\nModules The module is a representation of your git repository. Besides that, a module can have one or more applications, which means one or more components.\n","excerpt":" Circles Circles are groups of users created from specific …","ref":"/key-concepts/","title":"Key concepts"},{"body":" Circle Matcher Trata-se de um serviço HTTP que permite você identificar a qual segmentação o usuário pertence, a partir de regras lógicas previamente definidas. Para isso, o Circle Matcher recebe na requisição um JSON com os atributos sobre o usuário, e retorna uma lista de círculos.\nCírculos Círculos são grupos de usuários criados a partir de características específicas dentro de um mesmo ambiente na plataforma do Charles. Dessa forma, o desenvolvedor pode segmentar os usuários de acordo com as regras (AND ou OR) que mais fizerem sentido para testar aquela release.\nPor exemplo, é possível criar um círculo de engenheiros da região Norte do Brasil, outro de engenheiros do sudeste e um terceiro contendo todos os engenheiros brasileiros. Baseado nessa segmentação de clientes, pode-se elaborar diversas lógicas de deploy.\nComponentes Fazem parte dos módulos que são criados dentro do Charles. Os componentes funcionam como abstrações das aplicações, o que significa dizer que eles possuem suas próprias configurações e que cada parte deles corresponde a uma aplicação do módulo em que você estiver trabalhando. Caso você trabalhe com um monorepo, cada uma das suas aplicações serão cadastradas como componentes dentro de um único módulo.\nMar Aberto (Default) O termo, cunhado com o Charles, se refere a uma segmentação genérica em que estão presentes todos os usuários inseridos na plataforma que não estão vinculados a um círculo.\nOu seja, nessa segmentação estará uma versão padrão da sua aplicação, onde todos os usuários, que não estão associados a um teste de hipóteses, acessarão. É nessa segmentação também que, dada uma hipótese validada, deverá ser implantada uma nova release para que todos acessem.\nMódulos Módulo é a representação de um repositório no seu git. Além disso, um módulo pode conter uma ou mais aplicações, ou seja, um ou mais componentes.\n","excerpt":" Circle Matcher Trata-se de um serviço HTTP que permite você …","ref":"/pt/principais-conceitos/","title":"Principais Conceitos"},{"body":"","excerpt":"","ref":"/","title":"Docs"},{"body":"","excerpt":"","ref":"/pt/","title":"Docs"},{"body":" ","excerpt":" ","ref":"/pt/primeiros-passos/instalando-o-charles/","title":"Instalando o Charles"},{"body":"","excerpt":"","ref":"/get-started/installing-charles/","title":"Installing Charles"},{"body":" Components CharlesCD’s installation considers these components:\n Charles' architecture specific modules; Keycloak, used for the project’s authentication and authorization. However, if you already have an Identity Manager (IDM) and you want to use it, you have just to configure it during Charles' installation, check out how to enable it in the IDM section; A PostgreSQL database for backend modules (charlescd-moove, charlescd-butler ,charlescd-villager, charlescd-gate e charlescd-compass) and Keycloak; A Redis: To be used by charlescd-circle-matcher A RabbitMQ for charlescd-hermes' use. Ingress: It is used to expose the HTTP and HTTPS routes outside the cluster to services inside the cluster. When you install Charles, it already has a default ingress, however, if you want to use your own, see how to enable it in the Installing via Helm section.  Requirements To install Charles will be necessary an environment with the following requisites:\n Kubernetes. Helm Istio (version\u003e= 1.7 and enabled sidecar injection on the deploy namespace of your application). Prometheus, in case you want to use metrics  Resources The minimum resources considering only the installation of Charles are:\n Microk8s: 2GB of RAM; Minikube: 4GB of RAM. Cluster: 2GB of RAM  Next steps In this section, you saw components, requirements, and resources to install Charles. To continue the installation, see:\n","excerpt":" Components CharlesCD’s installation considers these components: …","ref":"/get-started/installing-charles/overview/","title":"Overview"},{"body":" Componentes A instalação do CharlesCD consiste nos seguintes componentes:\n  Módulos específicos da arquitetura do Charles.\n  Keycloak, usado para autenticação e autorização no projeto. Entretanto, caso você já tenha um Identity Manager (IDM) e queira utilizá-lo, basta fazer a sua configuração durante a instalação do Charles, veja como habilitá-lo na seção IDM.\n  Um banco PostgreSQL que servirá os módulos de backend (charlescd-moove\n, charlescd-butler, charlescd-villager, charlescd-gate, charlescd-hermes\ne charlescd-compass) e o Keycloak.\n  Um Redis para uso do charlescd-circle-matcher\n  Um RabbitMQ para uso do charlescd-hermes.\n  Ingress, usado para expor as rotas HTTP e HTTPs de fora do cluster para serviços dentro do cluster. Quando você instala o Charles, ele já possui uma ingress padrão, no entanto se você quiser usar a sua própria, veja os passos para habilitá-la na seção Instalando via Helm.\n  Pré-Requisitos Para instalar o Charles, será necessário um ambiente com os seguintes requisitos:\n Kubernetes Helm  Istio (versão \u003e= 1.7 e sidecar injector habilitado no namespace de deploy das suas aplicações). Prometheus, caso queira utilizar métricas.  Recursos mínimos Os recursos mínimos considerando apenas a instalação do Charles são:\n Microk8s: 2GB de RAM; Minikube: 4GB de RAM; Cluster: 2GB de RAM.  Próximos passos Nesta seção, você viu os componentes, pré-requisitos e recursos mínimos para instalar o Charles. Para continuar a instalação veja:\n","excerpt":" Componentes A instalação do CharlesCD consiste nos seguintes …","ref":"/pt/primeiros-passos/instalando-o-charles/vis%C3%A3o-geral/","title":"Visão Geral"},{"body":" Antes de prosseguir, tenha certeza de que todos os pré-requisitos estão devidamente instalados.  Como instalar? Esta instalação é customizável, para você instalar acesse um template helm com todos os campos disponíveis para alteração, incluindo os de banco de dados e recursos consumidos. Veja a documentação dos campos editáveis\nAs senhas utilizadas pelo Charles estão armazenadas no arquivo values.yaml As principais senhas para personalizar são:\n CharlesApplications.butler.database.password CharlesApplications.moove.database.password CharlesApplications.villager.database.password CharlesApplications.circlematcher.redis.password CharlesApplications.keycloak.keycloak.extraEnv.DB_PASSWORD CharlesApplications.postgresql.postgresqlPassword CharlesApplications.redis.password CharlesApplications.compass.database.password CharlesApplications.hermes.database.password CharlesApplications.rabbitmq.auth.password CharlesApplications.gate.database.password CharlesApplications.compass.moove.database.password  Para mais detalhes, acesse os campos editáveis.\n  Para garantir que as dependências dos charts estão presentes e atualizadas com uma versão compatível, utilize dentro da pasta /charlescd/install/helm-chart o comando abaixo:  helm dependency update  Para instalar com Helm Charts, depois que você customizou os campos, execute o comando abaixo dentro da pasta /charlescd/install/helm-chart:  helm install --create-namespace -n \u003cnamespace\u003e charlescd . -f values.yaml  Se você não fizer nenhuma customização, por padrão o Charles instala o PostgreSQL, Redis, Keycloak e RabbitMQ. Por isso, não deixe de customizar os campos se você precisa de algo gerenciável.  Troque a senha padrão (default password) Depois de instalar o CharlesCD, troque algumas senhas padrão, veja abaixo:\n  Senha do Keycloak:\n1. Acesse: http://\u003ccharlescd-url\u003e/keycloak/auth;\n2. Clique em Administration Console;\n3. Insira a senha do usuário do Keycloak (admin - firstpassword) e troque a senha padrão.\n  Senha do CharlesCD:\nAcesse o CharlesCD e logue com\n1. Usuário: charlesadmin@admin; 2. Senha: charlesadmin;\n3. Vá até Account \u003e Profile e depois em Change Password e escolha sua nova senha.\n  ","excerpt":" Antes de prosseguir, tenha certeza de que todos os pré-requisitos …","ref":"/pt/primeiros-passos/instalando-o-charles/instalando-via-helm/","title":"Instalando via Helm"},{"body":" Como fazer o deploy do CharlesCD no Kubernetes com o Terraform Para essa instalação não é necessário o kubectl, mas sem ele, você não poderá realizar alguns exemplos na nossa documentação. Se você quiser instalar, acesse a docs de instalação..  Requisitos Veja o que você precisa instalar na sua máquina:\n Docker Terraform  Como instalar? Siga os passos abaixo:\nStep 1 Faça o download no repositório charlescd-local-cluster. Na pasta charles-local-cluster, rode o comando:\nmake up Step 2 Acesse o http://charles.lvh.me/ no seu navegador e faça o login com:\n Usuário: charlesadmin@admin Senha: g_wl!U8Uyf2)$KKw  Agora você pode usar o CharlesCD!\n","excerpt":" Como fazer o deploy do CharlesCD no Kubernetes com o Terraform Para …","ref":"/pt/primeiros-passos/instalando-o-charles/installing-via-terraform/","title":"Instalando via Terraform"},{"body":" Before proceeding, make sure all the requirements are properly installed.  How to install? This installation stands out because of the customization. To do this, you have access to a helm template with all the available fields to change, including the database and the consumed resources.\nCheck out the documentation of the editable fields\nThe passwords used by Charles are stored in the values.yaml file. The main passwords to customized are:\n CharlesApplications.butler.database.password CharlesApplications.moove.database.password CharlesApplications.villager.database.password CharlesApplications.circlematcher.redis.password CharlesApplications.keycloak.keycloak.extraEnv.DB_PASSWORD CharlesApplications.postgresql.postgresqlPassword CharlesApplications.redis.password CharlesApplications.compass.database.password CharlesApplications.hermes.database.password CharlesApplications.rabbitmq.auth.password CharlesApplications.gate.database.password CharlesApplications.compass.moove.database.password  For more details, access the editable fields.\n  To make sure the charts dependencies are present and updated with a compatible version, use in the /charlescd/install/helm-chart folder the command below:  helm dependency update  To install with Helm Charts, after you have customized the fields, run the command below inside the /charlescd/install/helm-chart folder:  helm install --create-namespace -n \u003cnamespace\u003e charlescd . -f values.yaml  If you don’t customize anything, Charles installs by default PostgreSQL, Redis, Keycloak, and RabbitMQ. So, don’t forget to customize the fields if you want something manageable.  Change the default passwords After installing CharlesCD, remember to change some default passwords, check out below:\nKeycloak password:\n1. Access: http://\u003ccharlescd-url\u003e/keycloak/auth;\n2. Click on Administration Console;\n3. Enter with Keycloak user and password (admin - firstpassword) and change the default password.\nCharlesCD password:\nLog in CharlesCD with:\n1. User: charlesadmin@admin\n2. Password: charlesadmin;\n3. Go to Account \u003e Profile and then Change Password.\n","excerpt":" Before proceeding, make sure all the requirements are properly …","ref":"/get-started/installing-charles/installing-via-helm/","title":"Installing via Helm"},{"body":" Deploying CharlesCD on Kubernetes with Terraform This installation does not require kubectl, but you can’t perform some of the examples in our documentation without it. If you want to install it, check out the installation docs.  Requirements See below what you need in your machine:\n Docker Terraform  How to install? Follow the steps below:\nStep 1 Download at charlescd-local-cluster repository. From charles-local-cluster folder run:\nmake up Step 2 Access http://charles.lvh.me/ on your browser and log in with:\n User: charlesadmin@admin Password: g_wl!U8Uyf2)$KKw  Now you can start to play with CharlesCD!\n","excerpt":" Deploying CharlesCD on Kubernetes with Terraform This installation …","ref":"/get-started/installing-charles/installing-via-terraform/","title":"Installing via Terraform"},{"body":"Como fazer o deploy do CharlesCD no Kubernetes com o KinD Esta instalação não recomendada para ambientes de produção.. O time recomenda instalar se você quiser testar ou desenvolver o CharlesCD.  Para mais informações, acesse o repositório charlescd-local-cluster.\nRequisitos Veja o que você precisa instalar na sua máquina:\n Docker Helm KinD Kubectl  E siga os passos abaixo:\nPasso 1. Crie os clusters Kubernetes com KinD Você precisa encaminhar as portas do host para a ingress do Istio para conseguir acessar o Charles UI. Você pode fazer isso criando um cluster kind com extraPortMappings, veja abaixo:\ncat \u003c\u003cEOF | kind create cluster --name \"charles-testing\" --config=- kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 nodes: - role: control-plane image: kindest/node:v1.20.7 kubeadmConfigPatches: - | kind: InitConfiguration nodeRegistration: kubeletExtraArgs: node-labels: \"ingress-ready=true\" extraPortMappings: - containerPort: 30000 hostPort: 80 protocol: TCP - containerPort: 30001 hostPort: 443 protocol: TCP - containerPort: 30002 hostPort: 15021 protocol: TCP EOF Passo 2. Instale o Istio no Kubernetes  Instale o Istio Operator  Ao invés de instalar o Istio manualmente, você pode deixar o Istio Operator gerenciar isso para você:\nexport ISTIO_VERSION=1.7.8 curl -L https://istio.io/downloadIstio | sh - helm upgrade -i istio-operator ./istio-${ISTIO_VERSION}/manifests/charts/istio-operator \\ --set watchedNamespaces=\"istio-system\" \\ --set hub=\"docker.io/istio\" \\ --set tag=\"${ISTIO_VERSION}-distroless\"  Instale o Istio e configure a Istio Ingress como NodePort  Uma vez que o Istio Operator está instalado, crie o mapeamento de recurso do Kubernetes nas portas node que foram configuradas anteriomente no extraPortMappings:\nkubectl create namespace istio-system kubectl apply -f - \u003c\u003cEOF apiVersion: install.istio.io/v1alpha1 kind: IstioOperator metadata: name: control-plane namespace: istio-system spec: profile: demo components: egressGateways: - enabled: false name: istio-egressgateway ingressGateways: - enabled: true k8s: nodeSelector: ingress-ready: \"true\" service: ports: - name: status-port nodePort: 30002 port: 15021 targetPort: 15021 - name: http2 nodePort: 30000 port: 80 targetPort: 8080 - name: https nodePort: 30001 port: 443 targetPort: 8443 name: istio-ingressgateway values: gateways: istio-ingressgateway: type: NodePort global: defaultPodDisruptionBudget: enabled: false EOF Quando a instalação está completa e a pod da Igress do Istio está rodando, você poderá obter a verificação de integridade do serviço:\ncurl http://localhost:15021/healthz/ready -I Passo 3. Faça o deploy das aplicações empacotadas pelo Bitnami Helm Charts CharlesCD precisa de alguns componentes de infraestrutura para funcionar. Você precisar fazer o deploy desses componentes de forma rápida e fácil usando o Bitnami Helm Charts:\nhelm repo add bitnami https://charts.bitnami.com/bitnami Deploy Redis\nkubectl create namespace cache kubectl create secret generic redis -n cache --from-literal=password=\"cmXeuBSE6ElcCnEH\" helm upgrade -i redis bitnami/redis --version 15.3.2 -n cache \\ --set architecture=\"standalone\" \\ --set auth.existingSecret=\"redis\" \\ --set auth.existingSecretPasswordKey=\"password\" \\ --set image.tag=\"6.2.6-debian-10-r10\" \\ --set nameOverride=\"redis\" Deploy RabbitMQ\nkubectl create namespace queue helm upgrade -i rabbitmq bitnami/rabbitmq --version 8.22.0 -n queue \\ --set auth.erlangCookie=\"%d_3uIt\u0026B7qyh2Gc\" \\ --set auth.password=\"dI5FYfnN33i9xA9#\" \\ --set image.tag=\"3.9.7-debian-10-r17\" Deploy PostgreSQL\nPara salvar os seus recursos computacionais, use uma única instância Postgres. Para isso, crie um script para configurar toda a base de dados e os seus respectivos usuários:\ncat \u003c\u003c EOF \u003e ./userdata.sql -- CharlesCD Moove create database charlescd_moove_db; create user charlescd_moove with encrypted password 'GnozoAWuCGoIYF6Z'; alter user charlescd_moove with superuser; grant all privileges on database charlescd_moove_db to charlescd_moove; -- CharlesCD Villager create database charlescd_villager_db; create user charlescd_villager with encrypted password 'pnvvseJ8BW2jNsrc'; alter user charlescd_villager with superuser; grant all privileges on database charlescd_villager_db to charlescd_villager; -- CharlesCD Butler create database charlescd_butler_db; create user charlescd_butler with encrypted password 'fNq1milqfZI6v3aU'; alter user charlescd_butler with superuser; grant all privileges on database charlescd_butler_db to charlescd_butler; -- CharlesCD Hermes create database charlescd_hermes_db; create user charlescd_hermes with encrypted password 'SN1rLfyMG96CzZyl'; alter user charlescd_hermes with superuser; grant all privileges on database charlescd_hermes_db to charlescd_hermes; -- CharlesCD Compass create database charlescd_compass_db; create user charlescd_compass with encrypted password '5Pzmuji7NFYJAazk'; alter user charlescd_compass with superuser; grant all privileges on database charlescd_compass_db to charlescd_compass; -- CharlesCD Keycloak create database keycloak_db; create user keycloak with encrypted password 'seDnCGd3cz8G5QCy'; alter user keycloak with superuser; grant all privileges on database keycloak_db to keycloak; EOF Agora, crie uma secret com esse script e passe para initdbScriptsSecret:\nkubectl create namespace database kubectl create secret generic userdata --from-file=\"./userdata.sql\" helm upgrade -i postgresql bitnami/postgresql --version 10.9.5 -n database \\ --set fullnameOverride=\"postgresql\" \\ --set image.tag=\"13\" \\ --set initdbScriptsSecret=\"userdata\" Deploy Keycloak\nkubectl create namespace iam kubectl create secret generic database-env-vars -n iam \\ --from-literal=KEYCLOAK_DATABASE_HOST=\"postgresql.database.svc.cluster.local\" \\ --from-literal=KEYCLOAK_DATABASE_NAME=\"keycloak_db\" \\ --from-literal=KEYCLOAK_DATABASE_PORT=\"5432\" \\ --from-literal=KEYCLOAK_DATABASE_USER=\"keycloak\" kubectl create secret generic keycloak-passwords -n iam \\ --from-literal=adminPassword=\":gjUzkk{:h2bPB_6\" \\ --from-literal=databasePassword=\"seDnCGd3cz8G5QCy\" \\ --from-literal=managementPassword=\"cRF5mz:2oLKHdeT\" helm upgrade -i keycloak bitnami/keycloak --version 5.0.7 -n iam -f - \u003c\u003cEOF auth: adminUser: admin existingSecretPerPassword: adminPassword: name: keycloak-passwords databasePassword: name: keycloak-passwords managementPassword: name: keycloak-passwords externalDatabase: existingSecret: database-env-vars image: repository: bitnami/keycloak tag: \"15.0.2-debian-10-r52\" ingress: annotations: kubernetes.io/ingress.class: istio enabled: true hostname: keycloak.lvh.me pathType: Prefix nameOverride: keycloak postgresql: enabled: false service: type: ClusterIP EOF Passo 4. Configure o Keycloak realm, clientes e usuários Keycloak é responsável pelos usuários do CharlesCD, você precisa configurá-lo para isso. Há várias formas de configurar, mas nesse exemplo será com as APIs do Keycloak:\n# authorize with username / password ACCESS_TOKEN=$(curl -s 'http://keycloak.lvh.me/auth/realms/master/protocol/openid-connect/token' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --data-urlencode 'client_id=admin-cli' \\ --data-urlencode 'client_secret=a=Dg0\u003ePGyscSNu)i' \\ --data-urlencode 'grant_type=password' \\ --data-urlencode 'username=admin' \\ --data-urlencode 'password=:gjUzkk{:h2bPB_6' \\ | jq '.access_token' -r) # create realm curl -X POST 'http://keycloak.lvh.me/auth/admin/realms' \\ --header \"Authorization: Bearer ${ACCESS_TOKEN}\" \\ --header 'Content-Type: application/json' \\ --data-raw '{\"enabled\":true,\"id\":\"charlescd\",\"realm\":\"charlescd\"}' # create public client curl -X POST 'http://keycloak.lvh.me/auth/admin/realms/charlescd/clients' \\ --header \"Authorization: Bearer ${ACCESS_TOKEN}\" \\ --header 'Content-Type: application/json' \\ --data-raw '{\"clientId\":\"charlescd-client\",\"directAccessGrantsEnabled\":true,\"implicitFlowEnabled\":true,\"publicClient\":true,\"redirectUris\":[\"http://charles.lvh.me/*\"],\"serviceAccountsEnabled\":true,\"webOrigins\":[\"*\"]}' # create confidential client curl -X POST 'http://keycloak.lvh.me/auth/admin/realms/charlescd/clients' \\ --header \"Authorization: Bearer ${ACCESS_TOKEN}\" \\ --header 'Content-Type: application/json' \\ --data-raw '{\"clientId\":\"realm-charlescd\",\"secret\":\"vO]i?GSWWr0$zIZR\",\"serviceAccountsEnabled\":true,\"standardFlowEnabled\":false}' # create admin user curl -X POST 'http://keycloak.lvh.me/auth/admin/realms/charlescd/users' \\ --header \"Authorization: Bearer ${ACCESS_TOKEN}\" \\ --header 'Content-Type: application/json' \\ --data-raw '{\"username\":\"charlesadmin@admin\",\"enabled\":true,\"emailVerified\":true,\"email\":\"charlesadmin@admin\",\"attributes\":{\"isRoot\":[\"true\"]}}' # get admin user identifier USER_ID=$(curl -s 'http://keycloak.lvh.me/auth/admin/realms/charlescd/users?username=charlesadmin@admin' \\ --header \"Authorization: Bearer ${ACCESS_TOKEN}\" \\ | jq '.[0].id' -r) # create admin credentials curl -X PUT \"http://keycloak.lvh.me/auth/admin/realms/charlescd/users/${USER_ID}/reset-password\" \\ --header \"Authorization: Bearer ${ACCESS_TOKEN}\" \\ --header 'Content-Type: application/json' \\ --data-raw '{\"type\":\"password\",\"value\":\"g_wl!U8Uyf2)$KKw\",\"temporary\":false}' Passo 5. Faça o Deploy do CharlesCD Agora que todos os componentes necessários estão instalados e funcionando, você pode finalmente instalar o CharlesCD apontando para eles:\nexport CHARLESCD_VERSION=1.0.1 kubectl create namespace continuous-deployment curl https://github.com/ZupIT/charlescd/archive/refs/tags/${CHARLESCD_VERSION}.zip -OJL unzip ./charlescd-${CHARLESCD_VERSION}.zip ( cd ./charlescd-${CHARLESCD_VERSION}/install/helm-chart ; helm dependency update ) helm upgrade -i charlescd ./charlescd-${CHARLESCD_VERSION}/install/helm-chart -n continuous-deployment \\ --set CharlesApplications.butler.database.host=\"postgresql.database.svc.cluster.local\" \\ --set CharlesApplications.butler.database.name=\"charlescd_butler_db\" \\ --set CharlesApplications.butler.database.password=\"fNq1milqfZI6v3aU\" \\ --set CharlesApplications.butler.database.user=\"charlescd_butler\" \\ --set CharlesApplications.butler.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.butler.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.butler.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.butler.resources.limits=null \\ --set CharlesApplications.circleMatcher.allowedOriginHost=\"http://charles.lvh.me\" \\ --set CharlesApplications.circleMatcher.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.circleMatcher.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.circleMatcher.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.circleMatcher.redis.host=\"redis-master.cache.svc.cluster.local\" \\ --set CharlesApplications.circleMatcher.redis.password=\"cmXeuBSE6ElcCnEH\" \\ --set CharlesApplications.circleMatcher.resources.limits=null \\ --set CharlesApplications.compass.database.host=\"postgresql.database.svc.cluster.local\" \\ --set CharlesApplications.compass.database.name=\"charlescd_compass_db\" \\ --set CharlesApplications.compass.database.password=\"5Pzmuji7NFYJAazk\" \\ --set CharlesApplications.compass.database.user=\"charlescd_compass\" \\ --set CharlesApplications.compass.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.compass.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.compass.moove.database.host=\"postgresql.database.svc.cluster.local\" \\ --set CharlesApplications.compass.moove.database.name=\"charlescd_moove_db\" \\ --set CharlesApplications.compass.moove.database.password=\"GnozoAWuCGoIYF6Z\" \\ --set CharlesApplications.compass.moove.database.user=\"charlescd_moove\" \\ --set CharlesApplications.compass.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.compass.resources.limits=null \\ --set CharlesApplications.gate.database.host=\"postgresql.database.svc.cluster.local\" \\ --set CharlesApplications.gate.database.name=\"charlescd_moove_db\" \\ --set CharlesApplications.gate.database.password=\"GnozoAWuCGoIYF6Z\" \\ --set CharlesApplications.gate.database.user=\"charlescd_moove\" \\ --set CharlesApplications.gate.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.gate.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.gate.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.gate.resources.limits=null \\ --set CharlesApplications.hermes.amqp.url=\"amqp://user:dI5FYfnN33i9xA9#@rabbitmq.queue.svc.cluster.local:5672/\" \\ --set CharlesApplications.hermes.database.host=\"postgresql.database.svc.cluster.local\" \\ --set CharlesApplications.hermes.database.name=\"charlescd_hermes_db\" \\ --set CharlesApplications.hermes.database.password=\"SN1rLfyMG96CzZyl\" \\ --set CharlesApplications.hermes.database.user=\"charlescd_hermes\" \\ --set CharlesApplications.hermes.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.hermes.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.hermes.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.hermes.resources.limits=null \\ --set CharlesApplications.moove.allowedOriginHost=\"http://charles.lvh.me\" \\ --set CharlesApplications.moove.database.host=\"postgresql.database.svc.cluster.local\" \\ --set CharlesApplications.moove.database.name=\"charlescd_moove_db\" \\ --set CharlesApplications.moove.database.password=\"GnozoAWuCGoIYF6Z\" \\ --set CharlesApplications.moove.database.user=\"charlescd_moove\" \\ --set CharlesApplications.moove.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.moove.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.moove.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.moove.resources.limits=null \\ --set CharlesApplications.ui.allowedOriginHost=\"http://charles.lvh.me\" \\ --set CharlesApplications.ui.apiHost=\"http://charles.lvh.me\" \\ --set CharlesApplications.ui.authUri=\"http://keycloak.lvh.me\" \\ --set CharlesApplications.ui.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.ui.idmRedirectHost=\"http://charles.lvh.me\" \\ --set CharlesApplications.ui.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.ui.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.ui.resources.limits=null \\ --set CharlesApplications.villager.database.host=\"postgresql.database.svc.cluster.local\" \\ --set CharlesApplications.villager.database.name=\"charlescd_villager_db\" \\ --set CharlesApplications.villager.database.password=\"pnvvseJ8BW2jNsrc\" \\ --set CharlesApplications.villager.database.user=\"charlescd_villager\" \\ --set CharlesApplications.villager.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.villager.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.villager.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.villager.resources.limits=null \\ --set envoy.idm.endpoint=\"keycloak.lvh.me\" \\ --set envoy.idm.path=\"/auth/realms/charlescd/protocol/openid-connect/userinfo\" \\ --set hostGlobal=\"http://charles.lvh.me\" \\ --set ingress.enabled=\"false\" \\ --set keycloak.enabled=\"false\" \\ --set nginx_ingress_controller.enabled=\"false\" \\ --set postgresql.enabled=\"false\" \\ --set rabbitmq.enabled=\"false\" \\ --set redis.enabled=\"false\" Para acessar o CharlesCD UI no seu navegador, crie um recurso da Ingress utilizando o host charles.lvh.me. O serviço do DNS lvh.me sempre resolverá para 127.0.0.1 então, você não precisa modificar o arquivo /etc/hosts ou rodar no seu próprio servidor DNS:\nkubectl apply -f - \u003c\u003cEOF apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: kubernetes.io/ingress.class: istio name: charlescd namespace: continuous-deployment spec: rules: - host: charles.lvh.me http: paths: - backend: service: name: envoy-proxy port: number: 80 path: / pathType: Prefix EOF Agora, acesse http://charles.lvh.me/ no seu navegador::\n Faça o login com o usuário charlesadmin@admin Senha: g_wl!U8Uyf2)$KKw  Agora você pode usar o CharlesCD!\n","excerpt":"Como fazer o deploy do CharlesCD no Kubernetes com o KinD Esta …","ref":"/pt/primeiros-passos/instalando-o-charles/installing-via-kind/","title":"Instalando via Kind no seu ambiente local"},{"body":"Deploying CharlesCD on Kubernetes with KinD This is not recommended for a production environment. The team recommends this installation if you want to test and develop CharlesCD.  Requirements See below what you need in your machine:\n Docker Helm KinD Kubectl  Follow the next steps:\nStep 1. Create Kubernetes clusters with KinD You need to forward ports from the host to the Istio ingress to be able to access the Charles UI. You can do this by creating a kind cluster with extraPortMappings, see below:\ncat \u003c\u003cEOF | kind create cluster --name \"charles-testing\" --config=- kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 nodes: - role: control-plane image: kindest/node:v1.20.7 kubeadmConfigPatches: - | kind: InitConfiguration nodeRegistration: kubeletExtraArgs: node-labels: \"ingress-ready=true\" extraPortMappings: - containerPort: 30000 hostPort: 80 protocol: TCP - containerPort: 30001 hostPort: 443 protocol: TCP - containerPort: 30002 hostPort: 15021 protocol: TCP EOF Step 2. Install Istio on Kubernetes  Install Istio Operator  Instead of manually installing Istio you can let the Istio Operator manage this for you:\nexport ISTIO_VERSION=1.7.8 curl -L https://istio.io/downloadIstio | sh - helm upgrade -i istio-operator ./istio-${ISTIO_VERSION}/manifests/charts/istio-operator \\ --set watchedNamespaces=\"istio-system\" \\ --set hub=\"docker.io/istio\" \\ --set tag=\"${ISTIO_VERSION}-distroless\"  Install Istio and configure Istio Ingress as NodePort  Once Istio Operator is installed, just create its Kubernetes resource mapping the node ports that were previously configured on extraPortMappings:\nkubectl create namespace istio-system kubectl apply -f - \u003c\u003cEOF apiVersion: install.istio.io/v1alpha1 kind: IstioOperator metadata: name: control-plane namespace: istio-system spec: profile: demo components: egressGateways: - enabled: false name: istio-egressgateway ingressGateways: - enabled: true k8s: nodeSelector: ingress-ready: \"true\" service: ports: - name: status-port nodePort: 30002 port: 15021 targetPort: 15021 - name: http2 nodePort: 30000 port: 80 targetPort: 8080 - name: https nodePort: 30001 port: 443 targetPort: 8443 name: istio-ingressgateway values: gateways: istio-ingressgateway: type: NodePort global: defaultPodDisruptionBudget: enabled: false EOF When the installation is completed and the Istio Ingress pod is running, you’ll be able to get its health check endpoint:\ncurl http://localhost:15021/healthz/ready -I Step 3. Deploy applications packaged by Bitnami Helm Charts CharlesCD needs some infrastructure components to work. You have to deploy these components quickly and easily using Bitnami Helm Charts:\nhelm repo add bitnami https://charts.bitnami.com/bitnami Deploy Redis\nkubectl create namespace cache kubectl create secret generic redis -n cache --from-literal=password=\"cmXeuBSE6ElcCnEH\" helm upgrade -i redis bitnami/redis --version 15.3.2 -n cache \\ --set architecture=\"standalone\" \\ --set auth.existingSecret=\"redis\" \\ --set auth.existingSecretPasswordKey=\"password\" \\ --set image.tag=\"6.2.6-debian-10-r10\" \\ --set nameOverride=\"redis\" Deploy RabbitMQ\nkubectl create namespace queue helm upgrade -i rabbitmq bitnami/rabbitmq --version 8.22.0 -n queue \\ --set auth.erlangCookie=\"%d_3uIt\u0026B7qyh2Gc\" \\ --set auth.password=\"dI5FYfnN33i9xA9#\" \\ --set image.tag=\"3.9.7-debian-10-r17\" Deploy PostgreSQL\nUse a single Postgres instance to save your computing resources. Create a script to configure all databases and their respective users:\ncat \u003c\u003c EOF \u003e ./userdata.sql -- CharlesCD Moove create database charlescd_moove_db; create user charlescd_moove with encrypted password 'GnozoAWuCGoIYF6Z'; alter user charlescd_moove with superuser; grant all privileges on database charlescd_moove_db to charlescd_moove; -- CharlesCD Villager create database charlescd_villager_db; create user charlescd_villager with encrypted password 'pnvvseJ8BW2jNsrc'; alter user charlescd_villager with superuser; grant all privileges on database charlescd_villager_db to charlescd_villager; -- CharlesCD Butler create database charlescd_butler_db; create user charlescd_butler with encrypted password 'fNq1milqfZI6v3aU'; alter user charlescd_butler with superuser; grant all privileges on database charlescd_butler_db to charlescd_butler; -- CharlesCD Hermes create database charlescd_hermes_db; create user charlescd_hermes with encrypted password 'SN1rLfyMG96CzZyl'; alter user charlescd_hermes with superuser; grant all privileges on database charlescd_hermes_db to charlescd_hermes; -- CharlesCD Compass create database charlescd_compass_db; create user charlescd_compass with encrypted password '5Pzmuji7NFYJAazk'; alter user charlescd_compass with superuser; grant all privileges on database charlescd_compass_db to charlescd_compass; -- CharlesCD Keycloak create database keycloak_db; create user keycloak with encrypted password 'seDnCGd3cz8G5QCy'; alter user keycloak with superuser; grant all privileges on database keycloak_db to keycloak; EOF Now, just create a secret containing this script and pass it to initdbScriptsSecret:\nkubectl create namespace database kubectl create secret generic userdata --from-file=\"./userdata.sql\" helm upgrade -i postgresql bitnami/postgresql --version 10.9.5 -n database \\ --set fullnameOverride=\"postgresql\" \\ --set image.tag=\"13\" \\ --set initdbScriptsSecret=\"userdata\" Deploy Keycloak\nkubectl create namespace iam kubectl create secret generic database-env-vars -n iam \\ --from-literal=KEYCLOAK_DATABASE_HOST=\"postgresql.database.svc.cluster.local\" \\ --from-literal=KEYCLOAK_DATABASE_NAME=\"keycloak_db\" \\ --from-literal=KEYCLOAK_DATABASE_PORT=\"5432\" \\ --from-literal=KEYCLOAK_DATABASE_USER=\"keycloak\" kubectl create secret generic keycloak-passwords -n iam \\ --from-literal=adminPassword=\":gjUzkk{:h2bPB_6\" \\ --from-literal=databasePassword=\"seDnCGd3cz8G5QCy\" \\ --from-literal=managementPassword=\"cRF5mz:2oLKHdeT\" helm upgrade -i keycloak bitnami/keycloak --version 5.0.7 -n iam -f - \u003c\u003cEOF auth: adminUser: admin existingSecretPerPassword: adminPassword: name: keycloak-passwords databasePassword: name: keycloak-passwords managementPassword: name: keycloak-passwords externalDatabase: existingSecret: database-env-vars image: repository: bitnami/keycloak tag: \"15.0.2-debian-10-r52\" ingress: annotations: kubernetes.io/ingress.class: istio enabled: true hostname: keycloak.lvh.me pathType: Prefix nameOverride: keycloak postgresql: enabled: false service: type: ClusterIP EOF Step 4. Setup Keycloak realm, clients, and users Keycloak is in charge of CharlesCD users, you need to configure it for that. There are many ways you can do this, but in this example, it will be with Keycloak APIs:\n# authorize with username / password ACCESS_TOKEN=$(curl -s 'http://keycloak.lvh.me/auth/realms/master/protocol/openid-connect/token' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --data-urlencode 'client_id=admin-cli' \\ --data-urlencode 'client_secret=a=Dg0\u003ePGyscSNu)i' \\ --data-urlencode 'grant_type=password' \\ --data-urlencode 'username=admin' \\ --data-urlencode 'password=:gjUzkk{:h2bPB_6' \\ | jq '.access_token' -r) # create realm curl -X POST 'http://keycloak.lvh.me/auth/admin/realms' \\ --header \"Authorization: Bearer ${ACCESS_TOKEN}\" \\ --header 'Content-Type: application/json' \\ --data-raw '{\"enabled\":true,\"id\":\"charlescd\",\"realm\":\"charlescd\"}' # create public client curl -X POST 'http://keycloak.lvh.me/auth/admin/realms/charlescd/clients' \\ --header \"Authorization: Bearer ${ACCESS_TOKEN}\" \\ --header 'Content-Type: application/json' \\ --data-raw '{\"clientId\":\"charlescd-client\",\"directAccessGrantsEnabled\":true,\"implicitFlowEnabled\":true,\"publicClient\":true,\"redirectUris\":[\"http://charles.lvh.me/*\"],\"serviceAccountsEnabled\":true,\"webOrigins\":[\"*\"]}' # create confidential client curl -X POST 'http://keycloak.lvh.me/auth/admin/realms/charlescd/clients' \\ --header \"Authorization: Bearer ${ACCESS_TOKEN}\" \\ --header 'Content-Type: application/json' \\ --data-raw '{\"clientId\":\"realm-charlescd\",\"secret\":\"vO]i?GSWWr0$zIZR\",\"serviceAccountsEnabled\":true,\"standardFlowEnabled\":false}' # create admin user curl -X POST 'http://keycloak.lvh.me/auth/admin/realms/charlescd/users' \\ --header \"Authorization: Bearer ${ACCESS_TOKEN}\" \\ --header 'Content-Type: application/json' \\ --data-raw '{\"username\":\"charlesadmin@admin\",\"enabled\":true,\"emailVerified\":true,\"email\":\"charlesadmin@admin\",\"attributes\":{\"isRoot\":[\"true\"]}}' # get admin user identifier USER_ID=$(curl -s 'http://keycloak.lvh.me/auth/admin/realms/charlescd/users?username=charlesadmin@admin' \\ --header \"Authorization: Bearer ${ACCESS_TOKEN}\" \\ | jq '.[0].id' -r) # create admin credentials curl -X PUT \"http://keycloak.lvh.me/auth/admin/realms/charlescd/users/${USER_ID}/reset-password\" \\ --header \"Authorization: Bearer ${ACCESS_TOKEN}\" \\ --header 'Content-Type: application/json' \\ --data-raw '{\"type\":\"password\",\"value\":\"g_wl!U8Uyf2)$KKw\",\"temporary\":false}' Step 5. Deploy CharlesCD Now, all required components are up and running, you can finally install CharlesCD pointing to them:\nexport CHARLESCD_VERSION=1.0.1 kubectl create namespace continuous-deployment curl https://github.com/ZupIT/charlescd/archive/refs/tags/${CHARLESCD_VERSION}.zip -OJL unzip ./charlescd-${CHARLESCD_VERSION}.zip ( cd ./charlescd-${CHARLESCD_VERSION}/install/helm-chart ; helm dependency update ) helm upgrade -i charlescd ./charlescd-${CHARLESCD_VERSION}/install/helm-chart -n continuous-deployment \\ --set CharlesApplications.butler.database.host=\"postgresql.database.svc.cluster.local\" \\ --set CharlesApplications.butler.database.name=\"charlescd_butler_db\" \\ --set CharlesApplications.butler.database.password=\"fNq1milqfZI6v3aU\" \\ --set CharlesApplications.butler.database.user=\"charlescd_butler\" \\ --set CharlesApplications.butler.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.butler.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.butler.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.butler.resources.limits=null \\ --set CharlesApplications.circleMatcher.allowedOriginHost=\"http://charles.lvh.me\" \\ --set CharlesApplications.circleMatcher.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.circleMatcher.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.circleMatcher.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.circleMatcher.redis.host=\"redis-master.cache.svc.cluster.local\" \\ --set CharlesApplications.circleMatcher.redis.password=\"cmXeuBSE6ElcCnEH\" \\ --set CharlesApplications.circleMatcher.resources.limits=null \\ --set CharlesApplications.compass.database.host=\"postgresql.database.svc.cluster.local\" \\ --set CharlesApplications.compass.database.name=\"charlescd_compass_db\" \\ --set CharlesApplications.compass.database.password=\"5Pzmuji7NFYJAazk\" \\ --set CharlesApplications.compass.database.user=\"charlescd_compass\" \\ --set CharlesApplications.compass.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.compass.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.compass.moove.database.host=\"postgresql.database.svc.cluster.local\" \\ --set CharlesApplications.compass.moove.database.name=\"charlescd_moove_db\" \\ --set CharlesApplications.compass.moove.database.password=\"GnozoAWuCGoIYF6Z\" \\ --set CharlesApplications.compass.moove.database.user=\"charlescd_moove\" \\ --set CharlesApplications.compass.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.compass.resources.limits=null \\ --set CharlesApplications.gate.database.host=\"postgresql.database.svc.cluster.local\" \\ --set CharlesApplications.gate.database.name=\"charlescd_moove_db\" \\ --set CharlesApplications.gate.database.password=\"GnozoAWuCGoIYF6Z\" \\ --set CharlesApplications.gate.database.user=\"charlescd_moove\" \\ --set CharlesApplications.gate.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.gate.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.gate.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.gate.resources.limits=null \\ --set CharlesApplications.hermes.amqp.url=\"amqp://user:dI5FYfnN33i9xA9#@rabbitmq.queue.svc.cluster.local:5672/\" \\ --set CharlesApplications.hermes.database.host=\"postgresql.database.svc.cluster.local\" \\ --set CharlesApplications.hermes.database.name=\"charlescd_hermes_db\" \\ --set CharlesApplications.hermes.database.password=\"SN1rLfyMG96CzZyl\" \\ --set CharlesApplications.hermes.database.user=\"charlescd_hermes\" \\ --set CharlesApplications.hermes.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.hermes.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.hermes.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.hermes.resources.limits=null \\ --set CharlesApplications.moove.allowedOriginHost=\"http://charles.lvh.me\" \\ --set CharlesApplications.moove.database.host=\"postgresql.database.svc.cluster.local\" \\ --set CharlesApplications.moove.database.name=\"charlescd_moove_db\" \\ --set CharlesApplications.moove.database.password=\"GnozoAWuCGoIYF6Z\" \\ --set CharlesApplications.moove.database.user=\"charlescd_moove\" \\ --set CharlesApplications.moove.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.moove.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.moove.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.moove.resources.limits=null \\ --set CharlesApplications.ui.allowedOriginHost=\"http://charles.lvh.me\" \\ --set CharlesApplications.ui.apiHost=\"http://charles.lvh.me\" \\ --set CharlesApplications.ui.authUri=\"http://keycloak.lvh.me\" \\ --set CharlesApplications.ui.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.ui.idmRedirectHost=\"http://charles.lvh.me\" \\ --set CharlesApplications.ui.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.ui.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.ui.resources.limits=null \\ --set CharlesApplications.villager.database.host=\"postgresql.database.svc.cluster.local\" \\ --set CharlesApplications.villager.database.name=\"charlescd_villager_db\" \\ --set CharlesApplications.villager.database.password=\"pnvvseJ8BW2jNsrc\" \\ --set CharlesApplications.villager.database.user=\"charlescd_villager\" \\ --set CharlesApplications.villager.healthCheck.initialDelay=\"5\" \\ --set CharlesApplications.villager.image.tag=\"${CHARLESCD_VERSION}\" \\ --set CharlesApplications.villager.pullPolicy=\"IfNotPresent\" \\ --set CharlesApplications.villager.resources.limits=null \\ --set envoy.idm.endpoint=\"keycloak.lvh.me\" \\ --set envoy.idm.path=\"/auth/realms/charlescd/protocol/openid-connect/userinfo\" \\ --set hostGlobal=\"http://charles.lvh.me\" \\ --set ingress.enabled=\"false\" \\ --set keycloak.enabled=\"false\" \\ --set nginx_ingress_controller.enabled=\"false\" \\ --set postgresql.enabled=\"false\" \\ --set rabbitmq.enabled=\"false\" \\ --set redis.enabled=\"false\" To access CharlesCD UI on your browser, create an Ingress resource using the host charles.lvh.me. The wildcard DNS service lvh.me will always resolve to 127.0.0.1 so you don’t need to modify the /etc/hosts file or run your own DNS server:\nkubectl apply -f - \u003c\u003cEOF apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: kubernetes.io/ingress.class: istio name: charlescd namespace: continuous-deployment spec: rules: - host: charles.lvh.me http: paths: - backend: service: name: envoy-proxy port: number: 80 path: / pathType: Prefix EOF Now, access http://charles.lvh.me/ on your browser:\n Log in with the user charlesadmin@admin Password: g_wl!U8Uyf2)$KKw  Now you can start to play with CharlesCD!\n","excerpt":"Deploying CharlesCD on Kubernetes with KinD This is not recommended …","ref":"/get-started/installing-charles/installing-via-kind/","title":"Installing via Terraform local environment"},{"body":" No primeiro acesso, independente do método de instalação, o usuário padrão de administrador é charlesadmin@admin e a senha charlesadmin.\nLogo depois de fazer o primeiro login, troque essa senha.\n Há três formas de acessar a aplicação:\n Minikube. Microk8s. Cloud provider.  Veja abaixo como funciona a configuração para cada uma delas.\n1. Minikube No minikube, o load balancer nginx não cria automaticamente um IP externo. Para tornar isso possível, siga os passos:\nPasso 1: Execute o comando abaixo\nminikube tunnel // digite sua senha root, em uma nova aba do terminal e execute: kubectl get svc -n charles // agora o IP externo está disponível Passo 2: Agora que você tem um IP externo, troque o valor \u003cip-external-charles\u003e pelo IP externo e adicione essa linha no seu arquivo de host do OS:\n\u003cIP-EXTERNAL-CHARLES\u003e charles.info.example  Veja mais sobre como mudar o host do seu sistema.  Passo 3: Por fim, digite no seu navegador http://charles.info.example e a aplicação estará disponível.\n2. Microk8s O Microk8s está disponível para as Plataformas do Microsoft Windows, Apple MacOS e para Linux.\nAcesse o site do projeto para saber mais sobre como instalar o Microk8s  Uma vez instalado o Microk8s, você deve habilitar os seguintes add-ons:\n DNS: Descobrimento dos serviços dentro do cluster; Storage: Criação de volumes e persistências das PODs; MetalLB: Acesso aos serviços expostos pelo Kubernetes. Para este add-on, você terá que escolher um range de IPs onde o Load Balancer irá atribuir para a exposição dos seus serviços.  Siga os passos abaixo para habilitar o Microk8s no Charles: Passo 1: Prepare o Microk8s para receber o CharlesCD.\nmicrok8s enable dns storage metallb Enabling DNS Applying manifest serviceaccount/coredns created configmap/coredns created deployment.apps/coredns created service/kube-dns created clusterrole.rbac.authorization.k8s.io/coredns created clusterrolebinding.rbac.authorization.k8s.io/coredns created Restarting kubelet DNS is enabled Enabling default storage class deployment.apps/hostpath-provisioner created storageclass.storage.k8s.io/microk8s-hostpath created serviceaccount/microk8s-hostpath created clusterrole.rbac.authorization.k8s.io/microk8s-hostpath created clusterrolebinding.rbac.authorization.k8s.io/microk8s-hostpath created Storage will be available soon Enabling MetalLB Enter each IP address range delimited by comma (e.g. '10.64.140.43-10.64.140.49,192.168.0.105-192.168.0.111'): // Nesta etapa, você pode escolher um range ou usar o sugerido, vamos utilizar // 10.64.140.43-10.64.140.49 10.64.140.43-10.64.140.49 Applying registry manifest namespace/metallb-system created podsecuritypolicy.policy/speaker unchanged serviceaccount/controller created serviceaccount/speaker created clusterrole.rbac.authorization.k8s.io/metallb-system:controller unchanged clusterrole.rbac.authorization.k8s.io/metallb-system:speaker unchanged role.rbac.authorization.k8s.io/config-watcher created clusterrolebinding.rbac.authorization.k8s.io/metallb-system:controller unchanged clusterrolebinding.rbac.authorization.k8s.io/metallb-system:speaker unchanged rolebinding.rbac.authorization.k8s.io/config-watcher created daemonset.apps/speaker created deployment.apps/controller created configmap/config created MetalLB is enabled // Com o microk8s configurado, podemos então instalar o Charles usando // o single-file microk8s.kubectl create namespace charles ​​microk8s.kubectl apply -n charles -f https://raw.githubusercontent.com/ZupIT/charlescd/master/install/helm-chart/single-file.yaml // agora o IP externo está disponível microk8s.kubectl get svc -n charles Passo 2: Agora que você tem um IP externo, troque o valor \u003cip-external-charles\u003e pelo IP externo e adicione a linha no seu arquivo de host do OS:\n\u003cIP-EXTERNAL-CHARLES\u003e charles.info.example  Veja mais como mudar o host file.  Passo 3: Digite no seu navegador http://charles.info.example e a aplicação estará disponível.\n3. Cloud Provider (AWS, GCP, AZURE) No caso do Cloud Provider, você pode criar automaticamente o IP externo para o load balancer nginx ao fazer sua instalação em um cluster de kubernetes gerenciado.\nSiga os passos quando todos os componentes estiverem prontos.\nPasso 1: Obtenha o IP externo com o comando.\nkubectl get svc -n charles // get external IP value Passo 2: Adicione a linha abaixo no seu arquivo de host do OS (acesse o tutorial de como mudar o host) caso você queira acessar do browser da sua máquina:\n\u003cIP-EXTERNAL-CHARLES\u003e charles.info.example  Se você quiser usar essa instalação em ambientes de produção ou desenvolvimento, você precisa expor a aplicação usando um DNS.\nDepois de apontar seu DNS para o IP externo, faça o clone das configurações (seja o singlefile ou os arquivos do helm) e troque todas as ocorrências de http://charles.info.example para o seu novo DNS, depois execute o comando de instalação novamente.\n ","excerpt":" No primeiro acesso, independente do método de instalação, o usuário …","ref":"/pt/primeiros-passos/instalando-o-charles/seu-primeiro-acesso-ao-charles/","title":"Seu primeiro acesso ao Charles"},{"body":" At the first access, regardless of the installation method, the default admin user is charlesadmin@admin and the password is charlesadmin.\nIt is important that, after your first login, you change this password.\n There are three ways to access the application:\n Minikube; Microk8s; Cloud provider.  See below how the configuration works on each one of them:\n1. Minikube On the minikube, the load balancer does not automatically create an external IP, to make this possible, follow the steps:\nStep 1: Just run the command below:\nminikube tunnel // enter your root password, then open another terminal tab and run: kubectl get svc -n charles // now the nginx IP external appears Step 2: Now that you have the external ip, replace the ip-external-charles and add this line on your host file:\n\u003cIP-EXTERNAL-CHARLES\u003e charles.info.example  For more information on how to change the host file, access here.   Step 3: In your browser type http://charles.info.example and the entire application is available.\n2. Microk8s Microk8s is available for Microsoft Windows, Apple MacOS, and Linux platforms.\nFor more information on how to install Microk8s visit the project’s website  Once Microk8s is installed, you have to enable the following add-ons:\n DNS: discovery of services within the cluster; Storage: creating volumes and persistence of PODs; MetalLB: access to the services exposed by Kubernetes - For this addon, you will have to choose a range of IPs where Load Balancer will assign for the exposure of its services.  Follow the next steps to enable Microk8s on Charles:\nStep 1: prepare Microk8s to receive the CharlesCD;\nmicrok8s enable dns storage metallb Enabling DNS Applying manifest serviceaccount/coredns created configmap/coredns created deployment.apps/coredns created service/kube-dns created clusterrole.rbac.authorization.k8s.io/coredns created clusterrolebinding.rbac.authorization.k8s.io/coredns created Restarting kubelet DNS is enabled Enabling default storage class deployment.apps/hostpath-provisioner created storageclass.storage.k8s.io/microk8s-hostpath created serviceaccount/microk8s-hostpath created clusterrole.rbac.authorization.k8s.io/microk8s-hostpath created clusterrolebinding.rbac.authorization.k8s.io/microk8s-hostpath created Storage will be available soon Enabling MetalLB Enter each IP address range delimited by comma (e.g. '10.64.140.43-10.64.140.49,192.168.0.105-192.168.0.111'): // In this step, you can choose a range or use the suggested one, we will use // 10.64.140.43-10.64.140.49 10.64.140.43-10.64.140.49 Applying registry manifest namespace/metallb-system created podsecuritypolicy.policy/speaker unchanged serviceaccount/controller created serviceaccount/speaker created clusterrole.rbac.authorization.k8s.io/metallb-system:controller unchanged clusterrole.rbac.authorization.k8s.io/metallb-system:speaker unchanged role.rbac.authorization.k8s.io/config-watcher created clusterrolebinding.rbac.authorization.k8s.io/metallb-system:controller unchanged clusterrolebinding.rbac.authorization.k8s.io/metallb-system:speaker unchanged rolebinding.rbac.authorization.k8s.io/config-watcher created daemonset.apps/speaker created deployment.apps/controller created configmap/config created MetalLB is enabled // With microk8s configured, we can then install Charles using // the single-file microk8s.kubectl create namespace charles ​​microk8s.kubectl apply -n charles -f https://raw.githubusercontent.com/ZupIT/charlescd/master/install/helm-chart/single-file.yaml // now the nginx IP external appears microk8s.kubectl get svc -n charles Passo 2: now that you have the external ip, replace the ip-external-charles, add this line on your OS host file:\n\u003cIP-EXTERNAL-CHARLES\u003e charles.info.example  For more information on how to change the host file, check the tutorial  Step 3: type in your browser http://charles.info.example and the entire application will be available.\n3. Cloud Provider (AWS, GCP, AZURE) On Cloud Provider, if you install on a managed Kubernetes, the external ip for the nginx load balancer is created automatically,\nWhen all the components are ready follow the next steps:\nStep 1: Just take the external IP with the command below and add it to your hosts' file.\nkubectl get svc -n charles // get external IP value Step 2: Add the line below in your OS host file, if you want to access the browser on your device.\n\u003cIP-EXTERNAL-CHARLES\u003e charles.info.example  If you want to use this installation in a productive or development environment you will probably expose the application using a DNS.\nAfter doing this, clone the configurations (it can be single-file or the helm files) and change all occurrences from http://charles.info.example to your new DNS, then run the install command again.\n The purpose of this installation is only for tests. Using this for the production environment is not recommended due to lack o backup, high availability, etc.  ","excerpt":" At the first access, regardless of the installation method, the …","ref":"/get-started/installing-charles/your-first-charles-access/","title":"Your first Charles' access"},{"body":" O que é? As releases assinadas do CharlesCD permitem a verificação da procedência dos artefatos gerados na sua release.\nAs releases do Charles serão assinadas a partir da versão 1.0.2.  Como verificar? Para você verificar a assinatura, siga os passos abaixo:\nPasso 1. Acesse o repositório e escolha a release que você precisa fazer o download.\nPasso 2. Faça o download do artefato desejado (zip ou tar.gz), do checksum.txt e do checksum.txt.sig;\nPasso 3. Importe a chave pública do charles com o comando:\n gpg --recv-keys A8CDAF8572A7A5BD291E7469D3EA886A72F6D154 Passo 4. Cheque se a assinatura do checksum.txt é válida:\n gpg --verify checksum.txt.sig checksum.txt Passo 5. Cheque se o tgz baixado possui o checksum correspondente ao do repositório:\nsha256sum --check --ignore-missing checksums.txt Nesta seção, você encontra informações sobre releases assinadas do CharlesCD\nIn this section, you will find information about CharlesCD’s signed releases\n","excerpt":" O que é? As releases assinadas do CharlesCD permitem a verificação da …","ref":"/pt/primeiros-passos/instalando-o-charles/release-assinadas/","title":"Release assinadas"},{"body":" What is it? CharlesCD’s signed releases allow you to verify the origin of the artifacts generated in your release.\nCharlesCD will start to sign the releases in the 1.0.2 version.  How can you verify it? Follow the steps below to verify the signed release:\nStep 1. Access the repository and choose the release you need to download.\nStep 2. Download the artifact you need (zip or tar.gz), checksum.txt and checksum.txt.sig;\nStep 3. Import Charles' public key with the command below:\n gpg --recv-keys A8CDAF8572A7A5BD291E7469D3EA886A72F6D154 Step 4. Check if the checksum.txt signature is valid:\n gpg --verify checksum.txt.sig checksum.txt Step 5. Check if the downloaded tgz has the checksum corresponding to the repository:\nsha256sum --check --ignore-missing checksums.txt ","excerpt":" What is it? CharlesCD’s signed releases allow you to verify the …","ref":"/get-started/installing-charles/signed-releases/","title":"Signed Releases"},{"body":"","excerpt":"","ref":"/get-started/","title":"Get Started"},{"body":"","excerpt":"","ref":"/pt/primeiros-passos/","title":"Primeiros Passos"},{"body":"As configurações a seguir são opcionais, você pode escolher se é necessário configurar durante a instalação do Charles.\n","excerpt":"As configurações a seguir são opcionais, você pode escolher se é …","ref":"/pt/primeiros-passos/configura%C3%A7%C3%B5es-opcionais/","title":"Configurações opcionais"},{"body":" The following configuration are optional, you can choose if it is necessary to configure during Charles' installation:\n","excerpt":" The following configuration are optional, you can choose if it is …","ref":"/get-started/optional-configuration/","title":"Optional configuration"},{"body":" Por que autenticar? Em casos de registries privados, essa autenticação garantirá o sucesso na comunicação com o seu registry quando for preciso fazer o pull das imagens durante alguma implantação.\nComo autenticar? O cluster Kubernetes utiliza o tipo secret do docker-registy para autenticar o registry container.\nPara mais informações de como gerar esse secret para ser aplicado no seu cluster, acesse a documentação do Kubernetes.  Uma vez gerado o secret, ele ter uma formatação parecida com o exemplo abaixo:\napiVersion: v1 data: .dockerconfigjson: \u003c\u003cyour value\u003e\u003e kind: Secret metadata: name: \u003c\u003cregistry-name\u003e\u003e type: kubernetes.io/dockerconfigjson Com o secret em mãos, você precisará aplicar essa informação no namespace onde suas aplicações serão implantados pelo Charles:\nkubectl -n your-namespace apply secret-registry.yaml Finalizando desses passos, seu cluster conseguirá manter a comunicação com o registry.\n","excerpt":" Por que autenticar? Em casos de registries privados, essa …","ref":"/pt/primeiros-passos/configura%C3%A7%C3%B5es-opcionais/autenticando-com-registry-privado/","title":"Autenticando com registry privado"},{"body":" Why do you need to authenticate? Authentication is required if you use a private registry. This way, the cluster will be able to communicate with your registry to pull the images.\nHow do you authenticate? Kubernetes cluster uses a type of docker-registry Secret to authenticate the registry container. You have to generate it.\nFor more information on how to generate the Secret that will be applied in your cluster, check out the Kubernetes documentation.  Once you generate the secret, it will look like this:\napiVersion: v1 data: .dockerconfigjson: \u003c\u003cyour value\u003e\u003e kind: Secret metadata: name: \u003c\u003cregistry-name\u003e\u003e type: kubernetes.io/dockerconfigjson After this, you’ll need to apply this information in the namespace where your applications will be deployed by Charles:\nkubectl -n your-namespace apply secret-registry.yaml After completing these steps, your cluster will be able to maintain communication with the registry.\n","excerpt":" Why do you need to authenticate? Authentication is required if you …","ref":"/get-started/optional-configuration/authentication-with-private-registry/","title":"Authentication with private registry"},{"body":" Caso você queira utilizar sua ingress, ao invés da que possui na instalação do Charles, siga o seguinte passo:\n em charlescd/install/helm-chart/values.yaml, nas configurações de ingress, mude o valor de enabled para true como no exemplo abaixo.  ingress: enabled: true host: charles.info.example class: nginx ","excerpt":" Caso você queira utilizar sua ingress, ao invés da que possui na …","ref":"/pt/primeiros-passos/configura%C3%A7%C3%B5es-opcionais/configurando-sua-ingress/","title":"Configurando sua ingress"},{"body":" If you want to use your own ingress instead of the one provided with Charles' installation, follow the next step:\n On charlescd/install/helm-chart/values.yaml, change the enabled value to true, like the example below:  ingress: enabled: true host: charles.info.example class: nginx ","excerpt":" If you want to use your own ingress instead of the one provided with …","ref":"/get-started/optional-configuration/configuring-your-ingress/","title":"Configuring your ingress"},{"body":" A opção de Mutual Transport Layer Security (MTLS) é recomendada quando você quiser instalar o Charles em um cluster diferente de onde estão suas aplicações.  Essa configuração é necessária para garantir uma comunicação segura entre o serviços no Charles, já que podem estar expostos em cluster diferentes. Nesse cenário, apenas um componente do Charles precisa estar no mesmo cluster que as suas aplicações, o charlescd-butler.\nComo habilitar o MTLS? Siga os passos abaixo para habilitar o MTLS na sua aplicação:\nPasso 1: Acesse charlescd/install/mtls-job/values.yaml e coloque o domínio em que o Charles será utilizado, veja o exemplo abaixo:\nmtls: domain: .charles.com enabled: true Passo 2: Execute os manifestos, eles geram as secrets com os certificados de cada componente e a autoridade certificadora.\nThe certificates generated will be self-signed.  Passo 3: Na pasta raiz do projeto, execute o comando:\nhelm install mtls-job ./install/mtls-job/ --namespace charlescd --values=./install/mtls-job/values.yaml Passo 4: Se você quiser utilizar certificados próprios e não aqueles gerados pelo job, utilize o script de ‘create secrets’ para auxiliar na criação das secrets.\nPasso 5: Copie as secrets de um cluster para outro. E depois:\n Copie as secrets dentro de manifestos yaml, para fazer isso utilize o script de ‘copy secrets’; Aplique os manifestos no cluster destino, use o script de ‘apply secrets’.  Passo 6: Acesse charlescd/install/helm-chart/values.yaml nas configurações do moove e mude o valor da propriedade mtls/enabled para true. Veja abaixo:\nmoove: mtls: enabled: true Passo 7: Faça a mesma alteração do passo 6, mas agora para o componente butler, quando você instalá-lo em outro cluster, veja o exemplo:\nbutler: mtls: enabled: true Passo 8: Depois disso, siga os passos da instalação do Charles.\n","excerpt":" A opção de Mutual Transport Layer Security (MTLS) é recomendada …","ref":"/pt/primeiros-passos/configura%C3%A7%C3%B5es-opcionais/configurando-mtls/","title":"Configurando MTLS"},{"body":" Mutual Transport Layer Security (MTLS) is recommended when you want to install Charles in a different cluster where your applications are.  This configuration is necessary to guarantee safe communication between Charles' services because they can be exposed in a different cluster. In this scenario, only one Charles component needs to be in the same cluster of your applications: charlescd-butler.\nHow to enable MTLS? Follow the steps below to enable MTLS in your application:\nStep 1: Access charlescd/install/mtls-job/values.yaml and add the domain where you will use Charles, see the example below:\nmtls: domain: .charles.com enabled: true Step 2: Run the manifest, it generates secrets with certificates for each component and the certified authority.\nThe certificates generated will be self-signed.  Step 3: In the project’s root folder, run the command below:\nhelm install mtls-job ./install/mtls-job/ --namespace charlescd --values=./install/mtls-job/values.yaml Step 4: If you want to use your own certificates and not the ones generated by the job, use the ‘create secrets’ script to help you create secrets.\nStep 5: Copy a cluster’s secret to another, and now:\n Copy the secrets inside the yaml’s manifests, to do that use ‘copy secrets’ script; Apply the manifest in the destination cluster using the ‘apply secrets’ script.  Step 6: Access charlescd/install/helm-chart/values.yaml in moove’s configuration and change the property value mtls/enabled to true. Check out below:\nmoove: mtls: enabled: true Step 7: Make the same change you did in step 6, but now for the butler component, when you want to install in another cluster, see the example below:\nbutler: mtls: enabled: true Step 8: After that, follow Charles' installation steps.\n","excerpt":" Mutual Transport Layer Security (MTLS) is recommended when you want …","ref":"/get-started/optional-configuration/configuring-mtls/","title":"Configuring MTLS"},{"body":" O que é Identity Manager (IDM)? É o responsável por gerenciar a identidade dos usuários que acessarão uma determinada aplicação, neste caso, o Charles.\nQuando o usuário acessa o Charles, é verificado qual gerenciador responsável foi configurado durante a instalação para fazer a validação da identidade do usuário.  No exemplo da imagem abaixo, é ilustrado um fluxo onde se faz a verificação de qual foi a configuração feita para gerenciar os usuários. Nesse caso, quando o usuário tenta acessar o Charles e ainda não está autenticado, se tiver sido configurado um IDM personalizado, como o Google, por exemplo, o usuário é redirecionado para a própria página do Google para fazer a autenticação. Caso contrário, a tela de autenticação do Charles é retornada para dar sequência ao fluxo.\nPorque configurar um IDM? Para garantir a segurança dos acessos ao Charles, é necessário ter um gerenciador de identidade. Para isso, o Charles oferece duas opções:\nIDM Padrão Na instalação padrão do Charles, já existe o Keycloak que é utilizado para fazer a gestão dos usuários. Portanto, se você não tem um IDM personalizado que queira utilizar, a instalação padrão te oferece esse suporte.\nIDM Externa Caso você tenha seu próprio gerenciador de identidade, é necessário alterar algumas variáveis na instalação. Para isso, siga nossas instruções na referência sobre IDM.\nHá alguns fluxos bloqueados quando um IDM externo é utilizado, veja abaixo:\n Criação de usuário; Mudar senha; Reset de senha; Deleção de usuário.   ","excerpt":" O que é Identity Manager (IDM)? É o responsável por gerenciar a …","ref":"/pt/primeiros-passos/configura%C3%A7%C3%B5es-opcionais/definindo-o-identity-manager/","title":"Definindo o Identity Manager"},{"body":" What is Identity Manager (IDM)? It is responsible to manage the user identity that will access any application, in this case, Charles.\nWhen a user access Charles, it is verified which manager was configured during the installation, to make an identity validation of the user.  In the example below, you can see a flow where there is a verification of what configuration was made to manage the users. In this case, when a user tries to access Charles and it is not yet authenticated, if a customized IDM has been configurated, for example, Google, the user will be redirected to Google’s page to proceed with the authentication. If this is not the scenario, Charles' authentication screen is returned to continue the flow.\nWhy do you have to configure an IDM? It is necessary to have an identity manager to make sure Charle’s accesses are safe. For this, Charles offers two options:\nDefault IDM On Charles default installation, it already has Keycloak that it is used to manage the users. If you don’t have a customized IDM, you can use this one.\nExternal IDM In case you already have your own identity manager, it is necessary to change some installation variables. For that, follow the instructions in the [IDM’s section.] (https://docs.charlescd.io/reference/identity-manager/).\nThere are some blocked flows when using an external IDM, see below:\n Create users; Change password; Reset password; Delete users.   ","excerpt":" What is Identity Manager (IDM)? It is responsible to manage the user …","ref":"/get-started/optional-configuration/defining-the-identity-manager/","title":"Defining the Identity Manager"},{"body":"","excerpt":"","ref":"/get-started/defining-a-workspace/","title":"Defining a Workspace"},{"body":" ","excerpt":" ","ref":"/pt/primeiros-passos/definindo-um-workspace/","title":"Definindo um Workspace"},{"body":" The workspace allows you to segment CharlesCD’s use in your team, defining customized users' permissions that will assure safety to your project.\nYou need only one installation, and the teams will be able to use Charles with different configurations, or you may create a workspace to represent different development environments, such as staging, production, etc.  Workspace configuration Each workspace has the following configurations:\n Access control and user groups permissions; Git, Docker Registry Continuous Deployment (CD): Circle Matcher; Metrics provider.  The root user gives you permission to create a workspace. However, users with mantainer profile are able to configure with the necessary information as well.  How to get an identifier on my workspace? Once your workspace is created, even without the configuration definitions, it already has a single identifier.\nTo get this information, select the workspace you want, and then on the left menu, click on Copy ID.\n","excerpt":" The workspace allows you to segment CharlesCD’s use in your team, …","ref":"/get-started/defining-a-workspace/overview/","title":"Overview"},{"body":" O workspace permite que você segmente o uso do CharlesCD dentro da sua empresa ou do seu time. Com ele se define as permissões personalizadas dos usuários, o que garante mais segurança para o seu projeto.\nCom apenas uma instalação, vários times podem utilizar o Charles com configurações distintas ou, se preferir, criar um workspace para representar diferentes ambientes de desenvolvimento como, por exemplo, homologação, produção, etc.  Configurações do workspace Cada workspace possui as seguintes configurações:\n Definição dos acessos e permissões dos grupos de usuários. Cadastros de credenciais do Git, Docker Registry e de Continuous Deployment (CD). Personalização do Circle Matcher. Registro do Provedor de Métricas das suas aplicações.  A criação do workspace pode ser feita apenas pelo usuário root. Entretanto, o preenchimento das configurações podem também ser feitas pelos usuários associados ao workspace com perfil de mantenedor.  Como obter o identificador do meu workspace? Assim que seu workspace é criado, mesmo sem a definição das configurações, ele já possui um identificador único.\nPara obter essa informação, selecione o workspace desejado e, no menu à esquerda, clique em Copy ID:\n","excerpt":" O workspace permite que você segmente o uso do CharlesCD dentro da …","ref":"/pt/primeiros-passos/definindo-um-workspace/visao-geral/","title":"Visão Geral"},{"body":" Essa informação é obrigatória.  Durante a configuração do seu workspace, é necessário cadastrar o registry onde as imagens das suas aplicações estão armazenadas. Esse acesso é importante, pois uma vez configurado, o CharlesCD pode observar novas imagens sendo geradas e listar as imagens já salvas no seu registry para implantá-las.\nCharles já é integrado com alguns docker registries, escolha um e adicione as informações especificadas:\n","excerpt":" Essa informação é obrigatória.  Durante a configuração do seu …","ref":"/pt/primeiros-passos/definindo-um-workspace/docker-registry/","title":"Docker Registry"},{"body":" This is mandatory information.  One of the steps to configure your workspace is to inform Charles which docker registry you store your application’s images. This access is important because CharlesCD can watch newly generated images and list the ones already saved in your registry to deploy them in circles.\nCharles is already integrated with some docker registries, choose one and add the information:\n","excerpt":" This is mandatory information.  One of the steps to configure your …","ref":"/get-started/defining-a-workspace/docker-registry/","title":"Docker registry"},{"body":" O módulo de deploy aplica e monitora os recursos no cluster. E para fazer isso, ele utiliza o padrão Operator que realiza os ciclos de reconciliação garantindo que o cluster sempre estará no estado que você precisa. Os logs do Kubernetes também serão coletados em tempo real.\nConfigurando o workspace Ao configurar seu workspace é preciso cadastrar as credenciais de acesso ao cluster Kubernetes. Essas configurações são específicas para cada uma das ferramentas de Continuous Deployment (CD) que são integradas ao CharlesCD. No momento, o Charles realiza o deploy nativamente ou você pode integrar com o Spinnaker.\nConfiguração de Deployment O Charles possui uma arquitetura adaptável a diferentes instalações Kubernetes. O único requisito é que seu módulo de deploy esteja instalado no cluster de destino com uma URL acessível. A configuração de deployment indica qual é essa URL e quais credenciais do Git serão utilizadas para buscar os charts helm. Sem esta configuração o Charles não conseguirá realizar deploys.\nComo cadastrar a configuração? Siga os passos abaixo:\n Em Workspaces, no menu lateral esquerdo, selecione o workspace desejado, em seguida selecione Settings ; Clique em Credentials; Clique em Add Deployment Configuration;  Preencha os seguintes campos:\n Butler URL: URL do módulo de deploy Butler. Caso este esteja no mesmo cluster de instalação do Charles, utilize seu FQDN (Fully Qualified Domain Name). Exemplo: http://charlescd-butler.butler-namespace.svc.cluster.local:3000. Namespace: Defina o namespace em que os recursos serão disponibilizados no cluster. Você deve criar o seu namespace, uma vez que o Charles não faz isso; Git provider: Defina o provedor de git a ser utilizado (GitHub ou GitLab); Git token: Insira um token de autenticação que tenha acesso repositório git onde está armazenado seus templates Helm que serão utilizados durante o deployment da sua aplicação. Caso o seu Git Provider seja GitHub, é necessário a permissão “repo”. Se não, configure no GitLab os acessos: “api \" e “read_repository”.  To avoid dependency of a specific user in the authentication token field, use Machine Account.  ","excerpt":" O módulo de deploy aplica e monitora os recursos no cluster. E para …","ref":"/pt/primeiros-passos/definindo-um-workspace/ambiente-de-deploy/","title":"Ambiente de deploy"},{"body":" The deployment module monitors and applies the cluster resources. To do that, it uses the Operator pattern that performs reconciliation cycles to make sure that the cluster will always be in the state you need. Kubernetes' logs will also be collected in real-time.\nConfigure your workspace It is necessary to register cluster Kubernetes credentials to configure your workspace. These are specific configurations to each Continuous Deployment (CD) tool that is integrated with Charles. At the moment, Charles has a native deploy or you can integrate with Spinnaker.\nDeployment configuration Charles has an architecture that adapts to different Kubernetes installations. The only requirement is that your deployment module is installed on the destination cluster with an accessible URL. The deployment configuration indicates what URL is and which Git credentials will be used to search the helm charts. Without this configuration, Charles won’t be able to perform deploys.\nHow can you register the configuration? SFollow the steps below:\n In Workspaces, at the left menu, select your workspace and then click on Settings ; Click on Credentials; Click on Add Deployment Configuration;  Fill in these fields:\n Butler URL: Butler’s deploy module URL. If this is in the same Charles' installation cluster, use your FQDN (Fully Qualified Domain Name). Example: http://charlescd-butler.butler-namespace.svc.cluster.local:3000. Namespace: Define the namespace where the resources will be available in the cluster. You have to create your namespace, once Charles does not do it; Git provider: defines the git provider you will use (GitHub or GitLab); Git token: Insert an authentication token that has access to the git repository where your helm templates are stored (they will be used during the deployment of your application). If your Git Provider is GitHub, “repo” permission is required Otherwise, configure the accesses in GitLab: “API” and “read_repository”.  No campo token de autenticação para evitar a dependência de um usuário especifíco, utilize o Machine Account.  ","excerpt":" The deployment module monitors and applies the cluster resources. To …","ref":"/get-started/defining-a-workspace/deploy-environment/","title":"Deploy environment"},{"body":" Why do you have to configure it? When creating a workspace, you have to inform Charles to which Circle Matcher that current workspace will point to. It is possible that there is a Circle Matcher for each environment since Charles can handle, at the same time, different environments in multiple workspaces.\nCircle Matcher is an independent module, despite that, it is possible to install it in any area you want inside its architecture, for example, a public cluster.\nThis configuration is necessary, so you are able to perform operations in Charles, like creating and editing segments in a circle.\nIt is important to remember, in Charle’s context, the Circle Matcher module receives most of the environment’s requests because it is the application that identifies the user based on the rules that you have configured while managing a circle.  If you want to know more about Circle Matcher, check out the [Reference section] (https://docs.charlescd.io/reference/circle-matcher/).\nHow must be configured? Option 1: Configure Circle Matcher in a separate architecture You have to configure the public DNS that points to your desired Circle Matcher.\n Example: http://charles.info.example/charlescd-circle-matcher.\n Option 2: Configure Circle Matcher in the same Charles' namespace If you want to use Circle Matcher in the same namespace that Charles is installed, you can use the same DNS reference.\nThe difference is in terms of performance, it is recommended to use Kubernetes service name.\n Example: http://charlescd-circle-matcher:8080.\n Next steps In this section, you saw how to create your Circle Matcher. To continue your workspace configuration, Charles offers metrics that need to be configured.\n👉 Go to [Setting up your metrics] (https://docs.charlescd.io/reference/metrics/setting-up-your-metrics/) and find out how Charles uses metrics.\n","excerpt":" Why do you have to configure it? When creating a workspace, you have …","ref":"/get-started/defining-a-workspace/circle-matcher/","title":"Circle Matcher"},{"body":" Por que configurar? Quando você cria um workspace, é preciso informar ao Charles para qual Circle Matcher esse workspace atual apontará. É possível que haja um Circle Matcher para cada ambiente, já que o Charles lida, ao mesmo tempo, com diferentes ambientes em vários workspaces.\nApesar do Circle Matcher ser um módulo independente no Charles, é possível instalá-lo em qualquer área de preferência dentro da arquitetura como, por exemplo, em um cluster público.\nEssa configuração é necessária para que você possa executar operações dentro do Charles, como criar ou editar segmentos de um círculo.\nVale lembrar que, no contexto do Charles, o módulo do Circle Matcher é o que mais recebe solicitações no ambiente por identificar os usuários com base nas regras que você configurou ao gerenciar um círculo.  Se você deseja saber mais sobre o que é um Circle Matcher, veja a seção Referência.\nComo você deve configurar? Opção 1: Configurar o Circle Matcher em uma arquitetura à parte Você deve configurar o DNS público que aponta para o Circle Matcher desejado.\n Exemplo: http://charles.info.example/charlescd-circle-matcher.\n Opção 2: Configurar o Circle Matcher no mesmo namespace do Charles Caso prefira usar o Circle Matcher no mesmo namespace em que Charles está instalado, você pode usar a mesma referência de DNS.\nA diferença é que, em termos de desempenho, o mais recomendado é usar o nome do serviço do Kubernetes.\n Exemplo: http://charlescd-circle-matcher:8080.\n Próximos passos Nesta seção, você viu como criar seu Circle Matcher. Para continuar sua configuração de um workspace, o Charles oferece métricas que precisam ser configuradas.\n👉 Vá para página Configurando as métricas e descubra como Charles utiliza as métricas.\n","excerpt":" Por que configurar? Quando você cria um workspace, é preciso informar …","ref":"/pt/primeiros-passos/definindo-um-workspace/circle-matcher/","title":"Circle Matcher"},{"body":" Para quantificar a performance de suas aplicações e acompanhar o status delas, o Charles oferece dois tipos de DataSource: Prometheus e Google Analytics.\nAntes de adicionar o Datasource, é necessário ter finalizado a configuração de métricas.  Como configurar? Para realizar a configuração de cadastro, basta seguir os seguintes passos:\n Clique no seu nome, no canto inferior esquerdo e, em seguida, selecione Settings. Clique em Credentials; Clique em Add DataSource; Selecione a opção de ferramenta que você utiliza; Data source health: essa opção é para saber mais detalhes sobre a saúde do seu círculo. Faça a configuração baseada na ferramenta selecionada.  ","excerpt":" Para quantificar a performance de suas aplicações e acompanhar o …","ref":"/pt/primeiros-passos/definindo-um-workspace/adicionando-o-datasource/","title":"Adicionando o Datasource"},{"body":" In order to quantify your application’s performances and follow up on its status, Charles offers two types of Datasource: Prometheus and Google Analytics.\nBefore you add the Datasource, it is necessary to finish your metrics configuration.  How to configure? You have to follow the next steps:\n Click on your name, on the bottom left corner and then select Settings; Click on Credentials; Click on Add Datasource; Select your tool option; Data source health: this option gives you more details about your circle’s health; Make the configuration based on the selected tool.  ","excerpt":" In order to quantify your application’s performances and follow up on …","ref":"/get-started/defining-a-workspace/datasource/","title":"Datasource"},{"body":" O que é? Depois de cadastrar seu grupo de métricas, o Charles mostra o acompanhamento dessas métricas e oferece ações para cada uma delas. Ação é um tipo de trigger que será disparado quando todos os limites (thresholds) são alcançados.\nComo configurar? Em configurações do workspace, clique na seção Add Metric Action e siga os passos:\n1. Add action configuration: Adicione uma ação de configuração;\n2. Type a nickname: Escreva um nome para sua action;\n3. Type a description: Descreva o sua action;\n4. Select a plugin: Selecione um plugin para executar a ação.\nOs plugins disponíveis são circle deployment e circle undeployment. O Charles pode fazer o próprio plugin para atender às necessidades da sua aplicação como, por exemplo, uma action que envie e-mail para avisar o status do círculo.  Para mais informações sobre Action, veja a seção de Referência .\n","excerpt":" O que é? Depois de cadastrar seu grupo de métricas, o Charles mostra …","ref":"/pt/primeiros-passos/definindo-um-workspace/a%C3%A7%C3%B5es/","title":"Ações de métricas"},{"body":" What is it? After you had registered your metrics group, Charles follows up and offers actions for each one of them. Action is a kind of trigger that will be triggered when all the predetermined thresholds are reached.\nHow to configure? In workspace configuration, click on the section Add Metric Action and follow the steps:\nStep 1. Add action configuration;\nStep 2. Type a nickname for your action;\nStep 3. Type a description;\nStep 4. Select a plugin to run the action.\nThe available plugins are circle deployment and circle undeployment. Charles allows you to make your own plugin, the way you want and to fulfill your application’s purpose, for example, an action that sends an email to warn your circle status.  Inside your circle, you register the metrics group, which is responsible to create metrics that you want to track and you can also add action to this group. When you get to the threshold, the action will be triggered and what is described in your plugin will happen, like for example, make deployment of one circle in another circle.\nFor more information about Action, check out the Reference section.\n","excerpt":" What is it? After you had registered your metrics group, Charles …","ref":"/get-started/defining-a-workspace/metrics-actions/","title":"Metrics actions"},{"body":" What is it? Webhook is a resource that watches events in a system. When these events happen, the webhook sends a notification to people interested in receiving information about it.\nCharles has a module called charlescd-hermes responsible for identifying these events and send notifications to the subscribers when it happens.\nHow to register it? It is necessary to subscribe to use webhooks on Charles. Follow the steps below to do it:\n In Workspace, click on ‘Add Webhook’; Fill the fields:  Description: add the webhook description; Webhook URL: put the service URL; Secret (Optional): add the application key;   Choose the event: deploy, undeploy, or both.  After that, a card will appear with the success or fail status of the last message sent, see the image below:\nThe event’s information is sent in the content property. Your exposed service needs to accept this property in the request body.\nWebhook payload object common properties Each event payload contains unique properties. You can find them in the individual event type sections. See below the common properties:\n   Key Type Description     subscriptionId String Webhook’s id subscription.   executionId String Execution log id. Allows tracking all the message life cycle.   event Object Event detail.    Events The observable events are the beginning and end of deploy and undeploy.\nDeploy If you register a webhook to receive information about deploy events of a specific workspace, when a deploy automatically starts and ends, you will receive a notification with details of the event.\nWhen the event is triggered, an HTTP POST payload is sent to the subscribed webhook URL, see below:\n   Key Type Description     type String Event type. The possible values are\nSTART_DEPLOY and FINISH_DEPLOY    status String Event status. The possible values are SUCCESS and ERROR.   date String Event's execution date.   timeExecution Long Event's execution time.   worspaceId String Workspace Id.   author Object Information about the event's author.   circle Object Information about the circle's deploy/undeploy.   release String Deploy/undeploy information.   features Object Feature information if you are using the hypothesis board.   error String Error message in case there is a status with an error.    Deploy payload example { \"subscriptionId\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"executionId\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"event\": { \"type\": \"FINISH_DEPLOY\", \"status\": \"FAIL\", \"error\": \"Failed to pull image nexus.mydomain.co.uk/nginx Error: image nginx:latest not found\", \"date\": \"2020-01-10 22:00:00\", \"workspaceId\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"author\": { \"email\": \"charlescd@zup.com.br\", \"name\": \"CharlesCD\" }, \"circle\": { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"name\": \"circle-qas\" }, \"release\": { \"tag\": \"tag\", \"modules\": [ { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"name\": \"ZupIt/charlescd\", \"componentes\": [ { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"name\": \"charlescd-moove\" }, { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130004\", \"name\": \"charlescd-villager\" } ] }, { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130004\", \"name\": \"ZupIt/horusec\", \"componentes\": [ { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130005\", \"name\": \"horusec-account\" }, { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130006\", \"name\": \"horusec-analytics\" } ] } ], \"features\": [ { \"name\": \"new-moove-feature\", \"branchName\": \"feature/moove-feature\" }, { \"name\": \"new-horusec-feature\", \"branchName\": \"feature/horusec-feature\" } ] } } } Undeploy When you register a webhook to receive information about undeploy events of a specific workspace or when an undeployment automatically starts and ends, you will receive a notification with details of the event.\nWhen the event is triggered, an HTTP POST payload is sent to the subscribed webhook URL, see below:\n   Key Type Description     type String Event type. The possible values are\nSTART_DEPLOY and FINISH_DEPLOY    status String Event status. The possible values are SUCCESS and ERROR.   date String Event's execution date.   timeExecution Long Event's execution time.   worspaceId String Workspace Id.   author Object Information about the event's author.   circle Object Information about the circle's deploy/undeploy.   release String Deploy/undeploy information.   features Object Feature information if you are using the hypothesis board.   error String Error message in case there is a status with an error.    Event payload example { \"subscriptionId\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"executionId\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"event\": { \"type\": \"START_UNDEPLOY\", \"status\": \"SUCCESS\", \"date\": \"2020-01-10 22:00:00\", \"workspaceId\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"author\": { \"email\": \"charlescd@zup.com.br\", \"name\": \"CharlesCd\" }, \"circle\": { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"name\": \"circle-qas\" }, \"release\": { \"tag\": \"tag\", \"modules\": [ { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"name\": \"ZupIt/charlescd\", \"componentes\": [ { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"name\": \"charlescd-moove\" }, { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130004\", \"name\": \"charlescd-villager\" } ] }, { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130004\", \"name\": \"ZupIt/horusec\", \"componentes\": [ { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130005\", \"name\": \"horusec-account\" }, { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130006\", \"name\": \"horusec-analytics\" } ] } ], \"features\": [ { \"name\": \"new-moove-feature\", \"branchName\": \"feature/moove-feature\" }, { \"name\": \"new-horusec-feature\", \"branchName\": \"feature/horusec-feature\" } ] } } } ","excerpt":" What is it? Webhook is a resource that watches events in a system. …","ref":"/get-started/defining-a-workspace/webhooks/","title":"Webhooks"},{"body":" O que é? Webhook é um recurso que observa os eventos de um sistema. Quando os eventos acontecem, o webhook tem a função de enviar uma notificação para os interessados cadastrados em receber as informações desse evento.\nO Charles possui o módulo charlescd-hermes, que é responsável por identificar esses eventos e enviar aos inscritos as notificações.\nComo cadastrar? É necessário criar configurações de webhook para utilizar essa funcionalidade no Charle. Para isso, siga os passos abaixo:\n Em Workspace, clique em ‘Add Webhook’; Preencha os campos de:  Descrição: adicione a descrição do webhook; Webhook URL: coloque a URL do serviço; Secret (Opcional): adicione, se necessário, a chave de aplicação;   Escolha o evento: deploy, undeploy ou ambos.  Depois do cadastro, um card aparecerá com o status de sucesso ou erro da última mensagem enviada. Veja a imagem abaixo:\nAs informações do evento são enviadas na propriedade content. O seu serviço exposto precisa aceitar essa propriedade no corpo da requisição.\nPropriedade comum dos objetos do payload de webhook Cada payload de evento possui propriedades únicas. Você pode encontrá-las nas seções individuais de eventos. Abaixo estão as propriedades comuns:\n   Key Tipo Descrição     subscriptionId String O id da subscrição do Webhook.   subscriptionId String O id da subscrição do Webhook.   executionId String O id de execução do evento. Permite rastrear todo ciclo de vida da notificação.   event Object Detalhes do evento.    Eventos Os eventos observáveis são início e finalização de deploy e undeploy.\nDeploy Quando você cadastra um webhook para receber informações sobre eventos de deploy de um determinado workspace, ou quando um deploy for iniciado e finalizado automaticamente, você irá receber uma notificação com detalhes do evento.\nQuando o evento é disparado, um payload HTTP POST é enviado a URL do webhook cadastrado.\nVeja abaixo:\n   Key Tipo Descrição     type String Tipo do evento. Os valores possíveis são START_DEPLOY e FINISH_DEPLOY   status String Status do evento. Os valores possíveis são SUCCESS e ERROR.   date String Data de execução do evento.   timeExecution Long Tempo de execução do evento.   worspaceId String Id do workspace.   author Object Informações do autor do evento.   circle Object Informações do círculo do deploy/undeploy.   release String Informações do deploy/undeploy.   features Object Informações das features do deploy/undeploy.   error String Mensagem de erro em caso de status com erro.    Exemplo de payload do evento de Deploy { \"content\": \"{ \"subscriptionId\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"executionId\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"event\": { \"type\": \"FINISH_DEPLOY\", \"status\": \"FAIL\", \"error\": \"Failed to pull image nexus.mydomain.co.uk/nginx Error: image nginx:latest not found\", \"date\": \"2020-01-10 22:00:00\", \"workspaceId\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"author\": { \"email\": \"charlescd@zup.com.br\", \"name\": \"CharlesCD\" }, \"circle\": { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"name\": \"circle-qas\" }, \"release\": { \"tag\": \"tag\", \"modules\": [{ \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"name\": \"ZupIt/charlescd\", \"componentes\": [{ \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"name\": \"charlescd-moove\" }, { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130004\", \"name\": \"charlescd-villager\" } ] }, { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130004\", \"name\": \"ZupIt/horusec\", \"componentes\": [{ \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130005\", \"name\": \"horusec-account\" }, { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130006\", \"name\": \"horusec-analytics\" } ] } ], \"features\": [{ \"name\": \"new-moove-feature\", \"branchName\": \"feature/moove-feature\" }, { \"name\": \"new-horusec-feature\", \"branchName\": \"feature/horusec-feature\" } ] } } }\" } Undeploy Quando você cadastra um webhook para receber informações sobre eventos de undeploy, de um determinado workspace, quando um undeploy for iniciado e finalizado automaticamente você irá receber uma notificação com detalhes do evento.\nQuando o evento é disparado, um payload HTTP POST é enviado a URL do webhook cadastrado, veja abaixo:\n   Key Tipo Descrição     type String Tipo do evento. Os valores possíveis são START_UNDEPLOY e FINISH_UNDEPLOY   status String Status do evento. Os valores possíveis são SUCCESS e ERROR.   date String Data de execução do evento.   worspaceId String Id do workspace.   author Object Informações do autor do evento.   circle Object Informações do círculo do deploy/undeploy.   release String Informações do deploy/undeploy.   features Object Informações das features do deploy/undeploy.   error String Mensagem de erro em caso de status com erro.    Exemplo de payload do evento de Undeploy \"content\": \"{ \"subscriptionId\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"executionId\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"event\": { \"type\": \"START_UNDEPLOY\", \"status\": \"SUCCESS\", \"date\": \"2020-01-10 22:00:00\", \"workspaceId\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"author\": { \"email\": \"charlescd@zup.com.br\", \"name\": \"CharlesCd\" }, \"circle\": { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"name\": \"circle-qas\" }, \"release\": { \"tag\": \"tag\", \"modules\": [ { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"name\": \"ZupIt/charlescd\", \"componentes\": [ { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130003\", \"name\": \"charlescd-moove\" }, { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130004\", \"name\": \"charlescd-villager\" } ] }, { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130004\", \"name\": \"ZupIt/horusec\", \"componentes\": [ { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130005\", \"name\": \"horusec-account\" }, { \"id\": \"5d4c95b4-6f83-11ea-bc55-0242ac130006\", \"name\": \"horusec-analytics\" } ] } ], \"features\": [ { \"name\": \"new-moove-feature\", \"branchName\": \"feature/moove-feature\" }, { \"name\": \"new-horusec-feature\", \"branchName\": \"feature/horusec-feature\" } ] } } }\" } ","excerpt":" O que é? Webhook é um recurso que observa os eventos de um sistema. …","ref":"/pt/primeiros-passos/definindo-um-workspace/webhooks/","title":"Webhooks"},{"body":"","excerpt":"","ref":"/get-started/creating-your-first-module/","title":"Creating your first module"},{"body":"","excerpt":"","ref":"/pt/primeiros-passos/criando-seu-primeiro-m%C3%B3dulo/","title":"Criando seu primeiro módulo"},{"body":" After creating and configuring your workspace, it is necessary to add the modules.\nA module is your application stored in a Git repository previously registered.\nHow to create your modules? To add it, access the Modules menu on your workspace and set the following properties:\n Name: This field should be the junction of the organization and the module names, as it is in your git. For example: ZupIt/charlescd. URL Git: Your repository’s URL. For example https://github.com/ZupIT/charlescd. If you have a lot of applications on your repository, register them with the components and add the following:    Name of the component: application’s name, the same on your repository;\n  Metrics:\n Latency Threshold: latency (ms); HTTP Error Threshold: HTTP error (%).  In both cases, you must add a risk value that you want to receive an alert if your component reaches the rate.\n  Add Helm Chart repository: inform your repository where the helm template of your application is in, see the example on how to fill in the fields with this URL: https://gitlab.com/charlito/charlescd/moove?ref=master   Insert URL: http://gitlab.com; Insert Organization: charlito; Insert repository: charlescd; Insert path: moove; Insert branch: master.  See the image on how to create modules:\nFor more information about Helm Repository, check out how to configure Chart Template section.  How do I get my module identifier? As soon as your module is created, it already has a unique identifier. To obtain this information, select the desired module and, in the menu on the left, click Copy ID:\nWhat are components? Components are abstractions of the applications. If in your repository there are many applications, every component will match one of them.  How to obtain the component identifier? After selecting the module, copy the component id using the option on the three points of the card:\n","excerpt":" After creating and configuring your workspace, it is necessary to add …","ref":"/get-started/creating-your-first-module/overview/","title":"Overview"},{"body":" Depois de criar e configurar o seu workspace, agora é necessário adicionar os módulos.\nUm módulo é a sua aplicação que está armazenada em um repositório do Git cadastrado anteriormente.\nComo adicionar os módulos? Para adicionar os módulos, acesse o menu Modules no workspace desejado e preencha os campos:\n Nome: o nome deverá ser a junção da organização e a do módulo, como está no git. Por exemplo: ZupIt/charlescd. URL Git: informe a URL do seu repositório. Por exemplo: https://github.com Se seu repositório tem várias aplicações, cadastre-as como componentes e informe:    Name of the component: o nome da aplicação, conforme está no repositório.\n  Métricas:\n Latency Threshold: latência (ms); HTTP Error Threshold: erro HTTP (%).  Em ambos os casos, informe um valor de risco que você gostaria de ser alertado caso seu componente alcançasse ou ultrapassasse.\n  Add Helm Chart repository: informe o repositório onde o está o template do helm da sua aplicação e veja o exemplo de como preencher os campos com essa URL: https://gitlab.com/charlito/charlescd/moove?ref=master   Insert URL: http://gitlab.com; Insert Organization: charlito; Insert repository: charlescd; Insert path: moove; Insert branch: master.  Veja a imagem de como criar módulos:\nPara saber mais sobre a configuração do repositório do helm, acesse a seção Configurando o chart template.  Como obter o identificador do meu módulo? Assim que seu módulo é criado, ele já possui um identificador único. Para obter essa informação, selecione o módulo desejado e, no menu à esquerda, clique em Copy ID:\nO que são componentes? Componentes são abstrações das aplicações. Se dentro do seu repositório há múltiplas aplicações, cada componente corresponderá a uma delas.\nComo obter o identificador dos componentes? Após selecionar o módulo, copie o id do componente através da opção existente nos três pontos do cartão:\n","excerpt":" Depois de criar e configurar o seu workspace, agora é necessário …","ref":"/pt/primeiros-passos/criando-seu-primeiro-m%C3%B3dulo/visao-geral/","title":"Visão Geral"},{"body":" O que é o Helm? O Helm Charts é um gerenciador de pacotes que permite você definir, instalar e atualizar as aplicações no Kubernetes, independente do grau de complexidade.\nChart template no contexto do CharlesCD O Chart Template é usado como uma coleção de arquivos relacionados a configurações do Kubernetes.\nOs charts devem seguir o padrão do Helm, e precisam estar contidos dentro de uma pasta com o nome da componente cadastrada no Charles. Você não precisa executar nenhum comando para empacotar o chart, o Charles faz o download dos arquivos e finaliza tudo automaticamente.\nVeja abaixo o exemplo de um repositório contendo o chart da componente http-https-echo no GitHub:\nO módulo de deploy Butler utiliza charts helm para disponibilizar as suas aplicações no Cluster. Esses charts devem estar disponíveis em um repositório Github ou Gitlab e acessíveis por meio do token cadastrado na configuração de deployment. A URL deles é providenciada junto ao cadastro do módulo.\nSe você não tiver configurado o seu módulo, veja como fazer na seção: ‘Criando seu primeiro módulo’. É importante lembrar que você deve cadastrar a URL no módulo.  Templates O único requisito para que os templates funcionem com o Charles é que as labels component e tag estejam presentes nos manifestos do recurso Deployment.\nNão é necessário inserir os valores no arquivo de values do seu chart, o Charles irá provê-los automaticamente.  Veja o exemplo abaixo:\ncomponent: {{ .Values.component }} tag: {{ .Values.tag }} Internamente o Butler armazena os charts compilados em entidades que representam cada solicitação de deploy. Desta forma, o Charles realiza rollbacks mais eficientes.\nComo configurar o chart template? Siga os próximos passos para configurar o app de exemplo.\nPasso 1: Crie um diretório do chart template Salve os seus templates na sua ferramenta de versionamento. Assim que você criar um novo chart template, você precisa nomear o diretório com o mesmo nome do componente ao qual ele se refere. A estrutura abaixo contém os templates necessários para fazer o deployment de um módulo que possui um componente chamado “circles-sample”. O seu diretório precisa estar dessa forma:\nPasso 2: Configure os itens do diretório Configure o diretório, veja abaixo quais arquivos são necessários para você configurar:\n templates/ : contém os modelos.   deployment.yaml: descreve a estrutura de deployment. service.yaml: descreve a estrutura do service.   O arquivo Chart.yaml contém uma descrições como version, name, description. É necessário definir a version como “darwin”.\n  O arquivo circles-sample.yaml possui os valores que serão utilizados nos nossos templates.\n  Essas são as informações que o Charles precisa ter no templates, você também pode incrementar os templates como quiser.\nPasso 3: Adicione informações do Charles no seu template O Charles sobrescreve alguns campos nos arquivos de Values do Helm que podem ser adicionados ao seu template. Veja abaixo:\n \".Values.tag\": A tag escolhida na hora de criar a release. \".Values.component\": O nome do componente selecionado para o deployment. \".Values.circleId\": ID do círculo em que o deploy foi realizado. \".Values.image.url\": URL completa da imagem em que o deployment irá acontecer.  Para mais informações de como criar seu próprio template, acesse alguns exemplos no repositório do Charles.\nPasso 4: Execute o comando \"helm package .\" Depois que você configurou o diretório:\n Acesse a pasta “circles-sample”; Execute o comando “helm package .”.  Depois disso, você terá uma arquivo tgz com o nome de circles-samples-darwin. O Charles procura o tgz para executar o template.\n","excerpt":" O que é o Helm? O Helm Charts é um gerenciador de pacotes que permite …","ref":"/pt/primeiros-passos/criando-seu-primeiro-m%C3%B3dulo/configurando-o-chart-template/","title":"Configurando o chart template"},{"body":" What is Helm? Helm Charts is a package manager that allows you to define, install and update Kubernetes applications, regardless of the complexity.\nCharts template in CharlesCD context Chart Template is used like a file collection related to the Kubernetes configuration.\nThe charts must follow the Helm pattern and they need to be contained in a folder with the registered component on Charles. You don’t need to run any command to bundle the chart, Charles downloads and it finishes automatically.\nSee the below an example of a repository containing the component’s chart http-https-echo on GitHub:\nThe deployment module Butler uses helm charts to make your application available in the cluster. These charts must be available in a Github or Gitlab repository and accessible through a token, previously registered in the deployment configuration. The URL is provided along with the module registration.\nIf you haven’t configured your module yet, see how to do it in ‘Creating your module’ section. It is important to remember, you have to register the URL in this module.  Templates The only requirements for templates to work with Charles are labels component and tag to be present in the Deployment resource manifests.\nIt is not necessary to insert the values in the values files of your chart, Charles will provide them.  See the example below:\ncomponent: {{ .Values.component }} tag: {{ .Values.tag }} Butler internally stores the compiled charts in entities that represent each deployment request. Thereby, Charles can perform more efficient rollbacks.\nHow to configure the chart template? Follow the next steps to try out our sample app.\nStep 1: Create a chart template directory Save your templates in your versioning tool. When you create a new chart template, you need to name the directory with the same component’s name it refers to.\nThe structure below has the necessary templates to deploy a module that contains a component called “circles-sample”, your directory needs to look like this:\nStep 2: Configure the directory’s items After you have created the directory, now you have to configure it. See below the files you need to configure:\n  templates/: It has the models.\n deployment.yaml: Describes the deployment structure. service.yaml: Describes the service structure.    The Chart.yaml file contains the descriptions like version, name, description. It is necessary to define the version as “darwin”.\n  The circles-sample.yaml file has the values that will be used in the templates.\n  These are the information Charles needs to have on the templates, you can customize them if you want to.\nStep 3: Add Charles' information to your template Charles overwrites some Helm Values file fields, you can add them to your template. Check out below:\n \".Values.tag\": A tag you choose when creating arelease. \".Values.component\": Component’s name for the deployment. \".Values.circleId\": Circles ID where the deployment was made. \".Values.image.url\": Image’s URL where the deployment will happen.  For more information on how to create your own template, access Charles' repository examples.\nStep 4: Run the \"helm package .\" command After you have configured your directory:\n Access the “circles-sample” folder;; Execute o comando “helm package .”.  After that, you will have a tgz file with the circles-samples-darwin name. Charles looks for the tgz to execute the template.\n","excerpt":" What is Helm? Helm Charts is a package manager that allows you to …","ref":"/get-started/creating-your-first-module/how-to-configure-chart-template/","title":"How to configure Chart template"},{"body":" Por que configurar? Quando você trabalha em cenários com vários microsserviços, configurar os módulos é uma forma de garantir a propagação de header x-circle-id e com isso certificar o [roteamento dos usuários para as versões corretas]((https://docs.charlescd.io/pt/refer%C3%AAncia/c%C3%ADrculo/). Dessa forma, você torna possível que o usuário da sua base chegue na mesma versão de todos os microserviços que fazem parte do seu teste de hipótese.\nPor exemplo, se você testar uma feature entre microserviços que tenham integrações em um fluxo de abertura de conta, é necessário garantir que o usuário será redirecionado a todas as versões corretas que estão no teste de hipóteses, criado para esse fluxo.\nPara garantir isso, você pode utilizar uma biblioteca de propagação do header x-circle-id, que faz com que o id do círculo identificado pelo circle-matcher seja repassado entre todas as requisições dentro da malha de microserviço, garantindo assim, que os usuários sejam redirecionados para a versão correta do seu teste de hipótese.\nCaso exista um microserviço dentro do fluxo que não faz parte do seu teste, o valor do círculo será repassado, mas a sua requisição cairá em mar aberto, porque não há nenhuma versão destinada para aquele círculo.  Exemplo Veja o workflow abaixo que mostra como a configuração funciona:\n  Ao realizar a chamada de um microserviço, o id do círculo que o usuário pertence é obtido por meio do módulo circle-matcher. O id é inserido no header de todas as próximas requisições com a chave X-Circle-Id. A biblioteca de propagação possibilita repassar o x-circle-id no header para a chamada de um outro microserviço, no caso o butler.   No Charles quando acontece um teste de hipótese no butler, por exemplo, ele está integrado com o mooveque é o microserviço que atende as requisições do frontend.\nSe você quiser que sua requisição chegue na versão correta do butler, é preciso que o moove repasse o header X-Circle-Id (obtido por meio de uma requisição para o circle-matcher) nessas requisições feitas para ele. E se envolver mais de um microserviço, é preciso propagar o header para garantir que o usuário tenha a mesma versão daquele círculo.\nQuando acontece um teste no moove e se ele estiver integrado com o villager e o butler, a propagação do header X-Circle-Id faz com que você procure por versões do villager e do butler na mesma versão do moove, porém como esse não é o cenário, essas requisições entre o moove e suas integrações serão tratadas pelo mar aberto.\nComo adicionar? O Charles possui uma biblioteca (lib) que funciona para qualquer aplicação Java que utilize o Spring como framework e outra para .NET Core. As libs foram construídas por não existir nenhuma alternativa amplamente utilizada para esse cenário.\nPara usá-las, você precisa adicioná-las a sua aplicação:\n Lib para Java e Spring  Lib para .NET  O Node.js já possui uma lib, veja na página do npm.  ","excerpt":" Por que configurar? Quando você trabalha em cenários com vários …","ref":"/pt/primeiros-passos/criando-seu-primeiro-m%C3%B3dulo/configurando-seus-m%C3%B3dulos-para-propagar-o-id-do-c%C3%ADrculo/","title":"Configurando seus módulos para propagar o id do círculo"},{"body":" Why configure it? When you work with multiple microservices scenarios, you need to configure the modules to propagate the X-Circle-Id header that makes sure the requests are being redirected to the right version of your application. Then your user base will get to the same version of all microservice that are part of your hypothesis test.\nFor example, if you test a feature between microservices that have integration with an opening flow account, it is necessary to make sure your user will get to the correct versions that are on your hypothesis test, created for this specific flow.\nYou can do this using a library to propagate the X-Circle-Id header, which makes the circle id identified by the circle-matcherpass all the requests inside the microservice mesh, and the users will be redirected to the right hypothesis test version.\nIf there is a microservice inside this flow that isn’t part of your test, the circle value will be passed, but your request will fall into the open sea because there isn’t any version for that circle.  Example See below:\n  When you make a microservice request, circle matcher gets the circle id for this specific request. The id is inserted in the header with the X-Circle-Id key. The propagate header library makes it possible to pass the x-circle-id in the header to request to another microservice, in this case butler.   When a hypothesis test happens on butler, for example, it is integrated with moove which is a microservice that answers the requests on the front end.\nIf you want your request to get to the butler correct version, it is necessary that moove pass the x-Circle-Id header (obtained by circle matcher) in the requests made for it. If involves more than one microservice, you have to propagate the header to make sure the user gets the same version of that circle.\nWhen a test happens with moove module, for example, and if it is integrated with villager and butler, the x-circle-id header propagation makes you look for villager and butler versions that are the same moove ones, however, this is not the scenario, these requests between moove and its integration will be treated by the open sea.\nHow to add it? Charles has a library that works for any Java application that uses Spring as a framework and another one for .NET Core. These libs were built because there wasn’t another way used in these development environments.\nTo use them, you need to add them to your application:\n Lib para Java e Spring  Lib para .NET  For Node.js there is already a lib and you can check it on npm page  ","excerpt":" Why configure it? When you work with multiple microservices …","ref":"/get-started/creating-your-first-module/configuring-your-module-to-propagate-the-circles-id/","title":"Configuring your module to propagate the circle's Id"},{"body":"Injeção de propriedades é uma operação importante para preparar suas aplicações nos manifestos realizada pelo Butler.\nVeja abaixo quais são:\n name: Nome do recurso Kubernetes. Alguns recursos manejados pelo Charles precisam ter os seus nomes alterados para que seja possível disponibilizar versões diferentes de uma mesma aplicação em círculos diferentes. A propriedade name terá o seguinte valor: \u003coriginalManifest.metadata.name\u003e-\u003ctag\u003e-\u003cdeploymentId\u003e; originalManifest.metadata.name: Nome gerado pelo chart da aplicação; tag: Tag da imagem; deploymentId: Identificador único da entidade deployment criada pelo Butler.  Essa atualização ocorre apenas nos recursos do tipo Deployment.   namespace: Namespace destino do deployment. Este namespace é especificado durante a configuração do Workspace e indica em qual namespace o deployment acontecerá. Se os charts inserirem este valor nos manifestos, o Charles irá sobrescrevê-los. labels: Labels dos recursos Kubernetes. Para que o ciclo de reconciliação do Butler e as rotas criadas pelo Istio funcionem corretamente, é necessário que alguns labels estejam disponíveis em todos os recursos aplicados no cluster. São eles:  deploymentId: Identificador único da entidade deployment criada pelo Butler; circleId: Identificador único do círculo onde o deployment será criado.    Exemplo Veja abaixo um exemplo de um manifesto gerado após a compilação do chart:\napiVersion: apps/v1 kind: Deployment metadata: name: http-https-echo labels: component: http-https-echo tag: v1 spec: template: metadata: name: http-https-echo labels: component: http-https-echo tag: v1 spec: containers: - name: http-https-echo image: mendhak/http-https-echo:latest replicas: 1 selector: matchLabels: component: http-https-echo Após a injeção de propriedades este mesmo manifesto assumirá a seguinte forma:\napiVersion: apps/v1 kind: Deployment metadata: name: http-https-echo-v1-bc0e1df9-c008-4d86-b534-d782badf3741 namespace: example-namespace labels: component: http-https-echo tag: v1 deploymentId: bc0e1df9-c008-4d86-b534-d782badf3741 circleId: b4b62bc2-4dfd-4673-bc67-cc2cbcf9bb2f spec: template: metadata: name: http-https-echo labels: component: http-https-echo tag: v1 deploymentId: bc0e1df9-c008-4d86-b534-d782badf3741 circleId: b4b62bc2-4dfd-4673-bc67-cc2cbcf9bb2f spec: containers: - name: http-https-echo image: mendhak/http-https-echo:latest replicas: 1 selector: matchLabels: component: http-https-echo Depois dessa configuração você pode usar o Charles para realizar o deploy de suas aplicações em círculos segmentados.\n","excerpt":"Injeção de propriedades é uma operação importante para preparar suas …","ref":"/pt/primeiros-passos/criando-seu-primeiro-m%C3%B3dulo/injecao-de-propriedade/","title":"Injeção de propriedade"},{"body":"Properties injections is an important operation to prepare your application in the manifests performed by Butler.\nSee them below:\n name: Kubernetes’ resource name. Some resources managed by Charles need to have their names altered, in order to make different versions of the same application available in different circles. The property name will have the following value:  \u003coriginalManifest.metadata.name\u003e-\u003ctag\u003e-\u003cdeploymentId\u003e; originalManifest.metadata.name: Name generated by the application’s chart; tag: Image’s tag; deploymentId: Deployment’s entity unique identifier created by Butler.  This update only happens in Deployment’s type resources.    namespace: Your deployment’s namespace. This namespace is described during the Workspace configuration and indicates which namespace the deployment will happen. If the charts insert this value in the manifests, Charles will overwrite them.\n  labels: Kubernetes’ resources labels.\nIn order to make Butler’s reconciliation cycle and Istio’s routes created correctly work, some labels need to be available in all resources applied to the cluster. See them below:\n deploymentId: Unique identifier of the deployment’s entity created by Butler; circleId: Unique circle’s identifier where the deployment will be created.  Example See below an example of a generated manifest after the chart compilation:\n  apiVersion: apps/v1 kind: Deployment metadata: name: http-https-echo labels: component: http-https-echo tag: v1 spec: template: metadata: name: http-https-echo labels: component: http-https-echo tag: v1 spec: containers: - name: http-https-echo image: mendhak/http-https-echo:latest replicas: 1 selector: matchLabels: component: http-https-echo After the property injection, this same manifest will be:\napiVersion: apps/v1 kind: Deployment metadata: name: http-https-echo-v1-bc0e1df9-c008-4d86-b534-d782badf3741 namespace: example-namespace labels: component: http-https-echo tag: v1 deploymentId: bc0e1df9-c008-4d86-b534-d782badf3741 circleId: b4b62bc2-4dfd-4673-bc67-cc2cbcf9bb2f spec: template: metadata: name: http-https-echo labels: component: http-https-echo tag: v1 deploymentId: bc0e1df9-c008-4d86-b534-d782badf3741 circleId: b4b62bc2-4dfd-4673-bc67-cc2cbcf9bb2f spec: containers: - name: http-https-echo image: mendhak/http-https-echo:latest replicas: 1 selector: matchLabels: component: http-https-echo After this configuration, you can use Charles to perform deployment in your application in segmented circles.\n","excerpt":"Properties injections is an important operation to prepare your …","ref":"/get-started/creating-your-first-module/properties-injections/","title":"Properties injections"},{"body":" After you have created your first module and registered your [cluster crendentials,] (https://docs.charlescd.io/get-started/defining-a-workspace/docker-registry/) you have finished all the steps needed to make your first deployment.\nNow, it is necessary to create a release and provide it on the configured cluster.\n How to make the first deployment? On Charles you have to use container images already available in your configured registry to create a release.\nTo make your first deployment, follow the steps below:\n Go to Circles area; Select a circle. If you haven’t created one yet, there is a default circle option that makes your first deploy possible; Change the active circle filter to inactive; Select the “Insert a release” option; After that, select “Create a release” and fill the fields:  ‘Release name’: choose a name for your release; ‘Select a module’; Select a component'; Version name': type the name of your tag (it is necessary to be the same one shown in your Registry).    5 . Click on ‘Deploy’ button and wait for a status on the green card. When processing, you will see “deploying”, but at the end, it will show up as “deployed”.\nAfter the process above, your release is ready to deploy.  Open Sea deploy The open sea deployment is where you send your application to the registered segmentation on Charles.\nEvery open sea deploy is incremental.  Now, follow the next steps to the Open Sea deploy:\n On Charles homepage, click on Circles; Click on the Default circle (it represents the open sea) Click on Override release in upper right corner; Click on Search for ready releases; Type the release name created above (or use it again with a new version) and click on Deploy.  Finally, Charles will provide the created release on a cluster in the Open Sea. The deploy status will be shown and updated along the process.\nIncremental deploy The incremental deployment allows you to use the previous deployments and add them to the actual one. For example, you already made a Beagle deployment and now you want to do a Ritchie one, you will see both of them in your current circle status.\nIf you don’t choose the incremental deployment (choose override release, for example) what has been deployed before in your circle will be removed and it will remain only the current deployment.  To make an incremental deployment, follow the steps below:\n On Charles homepage, click on Circles; Click on Default circle; Click on Incremental Deployment on the left corner; Clique em Search for ready releases; Type your release name created in the previous steps (or you can reproduce again with a new version), select, and click on Deploy.  Check out below:\n","excerpt":" After you have created your first module and registered your [cluster …","ref":"/get-started/first-deploy/","title":"First Deploy"},{"body":" Após criar o seu primeiro módulo e cadastrar as credenciais do seu cluster, você completou todos os passos de configuração necessários para a realização do seu primeiro deploy. Agora, é necessário criar uma release e disponibilizá-la no cluster configurado.  Como fazer o primeiro deploy? No CharlesCD, é preciso utilizar imagens de containers já disponíveis no registry configurado para criar uma release.\nPara fazer seu primeiro deploy, siga os passos abaixo:\n Acesse a área “Círculos” (Circles); Selecione um [círculo] (https://docs.charlescd.io/pt/refer%C3%AAncia/c%C3%ADrculo/). Caso você não tenha criado um ainda, a opção que irá aparecer é a do círculo default para que seja possível você realizar o primeiro deploy; Altere o filtro do círculo de ativo para inativo; Selecione a opção “Insert a release\"; Depois selecione “Create a release” e preencha os campos:  ‘Release name’: escolha um nome para a sua release; ‘Select a module’: selecione um módulo; ‘Select a component’: selecione um componente; ‘Version name': digite o nome da tag (é necessário ser o mesmo nome que aparece cadastrado em seu Registry).    5 . Clique no botão “Deploy” e aguarde o status no card verde. Enquanto estiver em processo, irá aparecer “deploying”, mas ao final irá aparecer “deployed”.\nDepois que você realizou o processo acima, sua release está pronta para o deploy!  Deploy em mar aberto O deploy em mar aberto é aquele em que você envia sua aplicação para toda segmentação cadastrada no Charles.\nTodo deploy em mar aberto é incremental.  Para realizar o deploy neste caso, siga os passos abaixo:\n Na tela inicial do Charles, clique em Circles; Clique no círculo Default (Este representa o mar aberto); Clique em Override release no canto direito superior; Clique em Search for ready releases; Digite o nome da release criada nos passos acima (ou os reproduza novamente com uma nova versão), a selecione e clique em Deploy.  Depois disso, o Charles se encarregará de disponibilizar a release criada no cluster configurado em mar aberto. O status do deploy será exibido e atualizado conforme o progresso.\nDeploy incremental O deployment incremental permite você utilizar os deployments anteriores e adicioná-los ao atual. Por exemplo, você já fez um deployment do Beagle e agora quer fazer um do Ritchie, você verá os dois no estado atual do seu círculo.\nSe você não escolher o deploy incremental (escolher sobrescrever uma release) o que já foi deployado antes no seu circulo irá ser removido e ficará apenas o deploy atual.  Para realizar o deploy neste caso, siga os passos abaixo:\n Na tela inicial do Charles, clique em Circles; Clique no círculo Default Clique em Incremental Deployment no canto direito superior; Clique em Search for ready releases; Digite o nome da release criada nos passos acima (ou os reproduza novamente com uma nova versão), a selecione e clique em Deploy.  Veja abaixo:\n","excerpt":" Após criar o seu primeiro módulo e cadastrar as credenciais do seu …","ref":"/pt/primeiros-passos/primeiro-deploy/","title":"Primeiro Deploy"},{"body":" A partir do momento em que você começa a fazer seus deploys, o próximo passo é criar os primeiros círculos para melhor segmentação das suas aplicações.\nPara isso, siga os seguintes passos:\nCertifique-se de que você já tenha instalado e configurado o Circle Matcher no workspace antes de iniciar os passos abaixo.   Crie seu círculo; Utilize Circle Matcher para verificar se as regras lógicas criadas para as segmentações estão identificando corretamente os usuários. Faça o deploy no círculo criado.  ","excerpt":" A partir do momento em que você começa a fazer seus deploys, o …","ref":"/pt/primeiros-passos/usando-c%C3%ADrculos/","title":"Usando Círculos"},{"body":" From the moment you start to create your deploys, the next step is to create your first circles to make your application segmentation better.\nFollow the next steps:\nBefore you follow the steps, make sure you have already installed and configured Circle Matcher on your workspace   Create your circle; Use circle matcher to verify if the logic rules created for the segmentation are correctly identifying the users. Make your deployment on the circle created before.  ","excerpt":" From the moment you start to create your deploys, the next step is to …","ref":"/get-started/using-circles/","title":"Using Circles"},{"body":" Por que integrar o Charles ao seu pipeline de Continuous Delivery? Integrações são capazes de garantir mais velocidade ao seu time. A entrega contínua (CD) permite que você pegue o código armazenado no repositório e o entregue à produção (ou em qualquer outro ambiente) continuamente.\nA configuração de um CD gera um processo mais rápido e eficaz para colocar seu produto no mercado antes da concorrência, e isso permite que seu time crie novos recursos e correções de bugs para manter seus clientes satisfeitos.\nPré-requisitos Para integrar o Charles C.D. no seu pipeline, você precisa saber algumas informações. Veja abaixo quais são e como consegui-las:\n  x-charles-token: É um hash criado quando um token sistêmico é gerado. Caso tenha perdido o valor, é possível regerar essa informação. Veja mais detalhes na seção do token sistêmico. .\n  x-workspace-id: Esse Id representa o workspace onde suas configurações de ambiente e círculos estão. Copie o ID no menu existente ao visualizar o workspace.\n  module.id: Esse Id representa o projeto cadastrado no Charles.Copie o ID no menu existente ao visualizar o módulo.\n  component.id: Esse identificador representa o componente e pode ser buscado nos detalhes do módulo.\n  component.version: Neste campo informe o nome da tag da imagem do seu componente.\n  component.artifact: Este é o nome do artefato. Por exemplo: {YOUR-REGISTRY-URL}-{YOUR-IMAGE-NAME}:{YOUR-TAG-NAME}.\n  circle.id: Esse Id representa o círculo cadastrado no Charles.Copie o ID no menu existente ao visualizar o círculo.\n  build.id: Este Id representa a composição do deploy criada na primeira requisição[ citada abaixo]. Esta informação é retornada como valor da chave id na resposta em formato de JSON.\n  Como integrar? Você pode fazer essa integração utilizando um token sistêmico e uma sequência de requisições HTTPS. Veja como nos dois passos abaixo:\nPasso 1: Criar composição do deploy POST https://charles.info.example/moove/v2/builds/compose\nEsta requisição cria uma composição que representará sua release em um círculo. E você pode misturar versões diferentes com vários componentes.\nRequisição Headers\n   Key Tipo Descrição     x-charles-token String Token sistêmico.   x-workspace-id String Identificador do workspace.    Body Parameters: Todos obrigatórios\n   Key Tipo Descrição     releaseName String Nome escolhido para a release.   modules String Lista de módulos.   module object Objeto que representa o módulo.   module.id string Identificador do Módulo   module.components array Lista dos componentes que irão compor o deploy.   component Object Informações do autor do evento.   component.id string Identificador do componente.   component.version String Nome da tag da imagem.   component.artifact string Nome do artefato. Por exemplo: {YOUR-REGISTRY-URL}-{YOUR-IMAGE-NAME}:{YOUR-TAG-NAME}    Resposta { \"id\":\"0000053e-14cc-4bae-85df-364a70eb0000\", \"author\":{ \"id\":\"00000afe-aa7a-4536-be1b-34eaad4c0000\", \"name\":\"Charles Admin\", \"email\":\"admin@email.com\" }, \"createdAt\":\"2021-04-19 12:08:54\", \"features\":[ { \"id\":\"17c28af1-d7bf-4c8c-9895-ab4944fb5a9e\", \"name\":\"release-test-0.1\", \"branchName\":\"release-test-0.1\", \"authorId\":\"00000afe-aa7a-4536-be1b-34eaad4c0000\", \"authorName\":\"Charles Admin\", \"modules\":[ { \"id\":\"00000df6-6c34-4410-9bea-77ee56900000\", \"name\":\"ZupIT/charlescd\", \"gitRepositoryAddress\":\"https://github.com/zupit/charlescd\", \"helmRepository\":\"{HELM_URL}\", \"createdAt\":\"2020-11-20 13:11:31\", \"components\":[ { \"id\":\"00000143-8208-4f95-9986-10b909c00000\", \"name\":\"charlescd-ui\", }, { \"id\":\"000009ea-ada9-40fd-bddf-51c921200000\", \"name\":\"charlescd-moove\" } ] } ], \"createdAt\":\"2021-04-19 12:08:54\", \"branches\":[ \"https://github.com/zupit/charlescd/tree/release-test-0.1\" ] } ], \"tag\":\"release-test-0.1\", \"status\":\"BUILT\", \"deployments\":[] } Veja abaixo um exemplo da requisição no formato CURL:\ncurl 'https://charlescd.api.com/moove/v2/builds/compose' \\ -H 'x-workspace-id: 000009c4-9f58-4236-9936-ffcb04b00000' \\ -H 'x-charles-token: {YOUR_SYSTEM_TOKEN}' \\ -H 'content-type: application/json' \\ --data-binary '{ \"modules\":[ { \"id\":\"00000f6-6c34-4410-9bea-77ee56900000\", \"components\":[ { \"id\":\"000009ea-ada9-40fd-bddf-51c921200000\", \"version\":\"{YOUR-TAG-NAME}\", \"artifact\":\"{YOUR-REGISTRY-URL}-{YOUR-IMAGE-NAME}:{YOUR-TAG-NAME}\" }, { \"id\":\"00000143-8208-4f95-9986-10b909c00000\", \"version\":\"{YOUR-TAG-NAME}\", \"artifact\":\"{YOUR-REGISTRY-URL}-{YOUR-IMAGE-NAME}:{YOUR-TAG-NAME}\" } ] } ], \"releaseName\":\"release-test-0.1\" }' Passo 2: Implantar a release criada na requisição anterior em um círculo. POST https://charles.info.example/path=\"/moove/v2/deployments\nEsta requisição implanta a release composta criada anteriormente em um círculo.\nRequisição Headers: Todos obrigatórios:\n   Key Tipo Descrição     x-workspace-id String Identificador do workspace.   x-charles-token String Token sistêmico.    Body Parameters: Todos obrigatórios:\n   Key Tipo Descrição     circleId String Identificador do círculo que receberá o deployment.   buildId String Identificador do build criado na requisição anterior.    Resposta { \"id\":\"0000070c-1ed8-4d33-ad91-04ea50100000\", \"author\":{ \"id\":\"00000afe-aa7a-4536-be1b-34eaad400000\", \"name\":\"Charles Admin\", \"email\":\"admin@email.com\" }, \"createdAt\":\"2021-04-19 12:08:54\", \"deployedAt\":null, \"circle\":{ \"id\":\"000006b3-6e04-4c48-aca9-c9297e100000\", \"name\":\"Circle name\", \"author\":{ \"id\":\"00000afe-aa7a-4536-be1b-34eaad400000\", \"name\":\"Charles Admin\", \"email\":\"admin@email.com\" }, \"createdAt\":\"2021-04-15 17:25:56\", \"matcherType\":\"REGULAR\", \"rules\":{ \"type\":\"CLAUSE\", \"clauses\":[ { \"type\":\"RULE\", \"content\":{ \"key\":\"email\", \"value\":[ \"test\" ], \"condition\":\"EQUAL\" } } ], \"logicalOperator\":\"OR\" }, \"importedAt\":null, \"importedKvRecords\":0 }, \"buildId\":\"0000053e-14cc-4bae-85df-364a70e00000\", \"tag\":\"{IMAGE_TAG_NAME}\", \"status\":\"DEPLOYING\", \"artifacts\":[ { \"id\":\"00000652-e4fb-41c7-a6da-33bee0600000\", \"artifact\":\"{YOUR-REGISTRY-URL}-{YOUR-IMAGE-NAME}:{YOUR-TAG-NAME}\", \"version\":\"{IMAGE_TAG_NAME}\", \"createdAt\":\"2021-04-19 12:08:54\", \"componentName\":\"charlescd-ui\", \"moduleName\":\"ZupIT/charlescd\" }, { \"id\":\"000000d2-4a50-408a-be38-c8e932200000\", \"artifact\":\"{YOUR-REGISTRY-URL}-{YOUR-IMAGE-NAME}:{YOUR-TAG-NAME}\", \"version\":\"{IMAGE_TAG_NAME}\", \"createdAt\":\"2021-04-19 12:08:54\", \"componentName\":\"charlescd-moove\", \"moduleName\":\"ZupIT/charlescd\" } ] } Veja um exemplo da requisição no formato CURL:\ncurl 'https://charlescd.api.com/moove/v2/deployments' \\ -H 'x-workspace-id: 000009c4-9f58-4236-9936-ffcb04b00000' \\ -H 'x-charles-token: {YOUR_SYSTEM_TOKEN}' \\ -H 'content-type: application/json' \\ --data-binary '{ \"buildId\":\"82a7d53e-14cc-4bae-85df-364a70eb9df7\", \"circleId\":\"1611b6b3-6e04-4c48-aca9-c9297e18d66d\" }' Você pode acompanhar a conclusão dos deployments utilizando os Webhooks\n","excerpt":" Por que integrar o Charles ao seu pipeline de Continuous Delivery? …","ref":"/pt/primeiros-passos/configurando-o-charles-no-seu-pipeline/","title":"Configurando o Charles no seu pipeline"},{"body":" Why do you have to integrate Charles into your Continuous Delivery pipeline? Integrations speed up your team and the Continuous Delivery (CD) allows you to take the code stored in the repository and deliver it continuously to production (or any other environment).\nSetting up a CD creates a quick and effective process to put your product to market before the competition, and it allows your team to launch new features and bug fixes in order to make your client happy with the result.\nPrerequisites To integrate Charles C.D. into your pipeline, you will need to know some information. Check out below what they are and how to get them:\n x-charles-token: It is a hash created when a systemic token is generated. If it has lost its value, it is possible to regenerate this information. See more details in the systemic token section. x-workspace-id: This Id represents the workspace where your environment settings and circles are. Copy the ID in the existing menu when viewing the workspace. module.id: This Id represents the project registered with Charles. Copy the ID in the existing menu when viewing the module. component.id: This identifier represents the component and it can be found in the module details. component.version: It is where you inform the name of the tag of your component’s image. component.artifact: This is the name of the artifact. For example: {YOUR-REGISTRY-URL}-{YOUR-IMAGE-NAME}:{YOUR-TAG-NAME}. circle.id: This Id represents the circle registered in Charles. [Copy the ID in the existing menu when viewing the circle] (https://docs.charlescd.io/reference/circle-matcher/). build.id: This Id represents the deployment’s composition created in the first request mentioned below. This information is returned as the value of the ID key in the JSON format response.  How to integrate? You can do this integration using a systemic token and a sequence of HTTPS requests. See below the two steps:\nStep 1: Create deployment composition (aka build) POST https://charles.info.example/moove/v2/builds/compose\nThis request creates a composition that represents your release in a circle. You can mix two different versions with several components.\nRequest Headers\n   Key Tipo Descrição     x-charles-token String Systemic Token   x-workspace-id String Workspace’s identifier.    Body Parameters: All required:\n   Key Type Description     releaseName String Release name.   modules String List of modules.   module object An object that represents the modules.   module.id string Module’s identifier.   module.components array List of components that composes the deployment.   component Object Information about the author’s event.   component.id string Component’s identifier.   component.version String Image tag name.   component.artifact string Artifact name. For example {YOUR-REGISTRY-URL}-{YOUR-IMAGE-NAME}:{YOUR-TAG-NAME}    Response { \"id\":\"0000053e-14cc-4bae-85df-364a70eb0000\", \"author\":{ \"id\":\"00000afe-aa7a-4536-be1b-34eaad4c0000\", \"name\":\"Charles Admin\", \"email\":\"admin@email.com\" }, \"createdAt\":\"2021-04-19 12:08:54\", \"features\":[ { \"id\":\"17c28af1-d7bf-4c8c-9895-ab4944fb5a9e\", \"name\":\"release-test-0.1\", \"branchName\":\"release-test-0.1\", \"authorId\":\"00000afe-aa7a-4536-be1b-34eaad4c0000\", \"authorName\":\"Charles Admin\", \"modules\":[ { \"id\":\"00000df6-6c34-4410-9bea-77ee56900000\", \"name\":\"ZupIT/charlescd\", \"gitRepositoryAddress\":\"https://github.com/zupit/charlescd\", \"helmRepository\":\"{HELM_URL}\", \"createdAt\":\"2020-11-20 13:11:31\", \"components\":[ { \"id\":\"00000143-8208-4f95-9986-10b909c00000\", \"name\":\"charlescd-ui\", }, { \"id\":\"000009ea-ada9-40fd-bddf-51c921200000\", \"name\":\"charlescd-moove\" } ] } ], \"createdAt\":\"2021-04-19 12:08:54\", \"branches\":[ \"https://github.com/zupit/charlescd/tree/release-test-0.1\" ] } ], \"tag\":\"release-test-0.1\", \"status\":\"BUILT\", \"deployments\":[] } Check out an example of the request in CURL format:\ncurl 'https://charlescd.api.com/moove/v2/builds/compose' \\ -H 'x-workspace-id: 000009c4-9f58-4236-9936-ffcb04b00000' \\ -H 'x-charles-token: {YOUR_SYSTEM_TOKEN}' \\ -H 'content-type: application/json' \\ --data-binary '{ \"modules\":[ { \"id\":\"00000f6-6c34-4410-9bea-77ee56900000\", \"components\":[ { \"id\":\"000009ea-ada9-40fd-bddf-51c921200000\", \"version\":\"{YOUR-TAG-NAME}\", \"artifact\":\"{YOUR-REGISTRY-URL}-{YOUR-IMAGE-NAME}:{YOUR-TAG-NAME}\" }, { \"id\":\"00000143-8208-4f95-9986-10b909c00000\", \"version\":\"{YOUR-TAG-NAME}\", \"artifact\":\"{YOUR-REGISTRY-URL}-{YOUR-IMAGE-NAME}:{YOUR-TAG-NAME}\" } ] } ], \"releaseName\":\"release-test-0.1\" }' Step 2: Deploy the release created in the previous request in a circle. POST https://charles.info.example/path=\"/moove/v2/deployments\nThis request implements the composite release, previously created in a circle.\nRequest Headers: All required:\n   Key Type Description     x-workspace-id String Workspace’s Identifier.   x-charles-token String Systemic Token.    Body Parameters: All required:\n   Key Type Description     circleId String Identifier of the circle that will receive the deployment.   buildId String Build identifier created in the previous request.    Response { \"id\":\"0000070c-1ed8-4d33-ad91-04ea50100000\", \"author\":{ \"id\":\"00000afe-aa7a-4536-be1b-34eaad400000\", \"name\":\"Charles Admin\", \"email\":\"admin@email.com\" }, \"createdAt\":\"2021-04-19 12:08:54\", \"deployedAt\":null, \"circle\":{ \"id\":\"000006b3-6e04-4c48-aca9-c9297e100000\", \"name\":\"Circle name\", \"author\":{ \"id\":\"00000afe-aa7a-4536-be1b-34eaad400000\", \"name\":\"Charles Admin\", \"email\":\"admin@email.com\" }, \"createdAt\":\"2021-04-15 17:25:56\", \"matcherType\":\"REGULAR\", \"rules\":{ \"type\":\"CLAUSE\", \"clauses\":[ { \"type\":\"RULE\", \"content\":{ \"key\":\"email\", \"value\":[ \"test\" ], \"condition\":\"EQUAL\" } } ], \"logicalOperator\":\"OR\" }, \"importedAt\":null, \"importedKvRecords\":0 }, \"buildId\":\"0000053e-14cc-4bae-85df-364a70e00000\", \"tag\":\"{IMAGE_TAG_NAME}\", \"status\":\"DEPLOYING\", \"artifacts\":[ { \"id\":\"00000652-e4fb-41c7-a6da-33bee0600000\", \"artifact\":\"{YOUR-REGISTRY-URL}-{YOUR-IMAGE-NAME}:{YOUR-TAG-NAME}\", \"version\":\"{IMAGE_TAG_NAME}\", \"createdAt\":\"2021-04-19 12:08:54\", \"componentName\":\"charlescd-ui\", \"moduleName\":\"ZupIT/charlescd\" }, { \"id\":\"000000d2-4a50-408a-be38-c8e932200000\", \"artifact\":\"{YOUR-REGISTRY-URL}-{YOUR-IMAGE-NAME}:{YOUR-TAG-NAME}\", \"version\":\"{IMAGE_TAG_NAME}\", \"createdAt\":\"2021-04-19 12:08:54\", \"componentName\":\"charlescd-moove\", \"moduleName\":\"ZupIT/charlescd\" } ] } Check out an example of the request in CURL format:\ncurl 'https://charlescd.api.com/moove/v2/deployments' \\ -H 'x-workspace-id: 000009c4-9f58-4236-9936-ffcb04b00000' \\ -H 'x-charles-token: {YOUR_SYSTEM_TOKEN}' \\ -H 'content-type: application/json' \\ --data-binary '{ \"buildId\":\"82a7d53e-14cc-4bae-85df-364a70eb9df7\", \"circleId\":\"1611b6b3-6e04-4c48-aca9-c9297e18d66d\" }' You can follow up on the deployments' completion using Webhooks.\n","excerpt":" Why do you have to integrate Charles into your Continuous Delivery …","ref":"/get-started/integrating-charles-to-your-ci/","title":"Integrating Charles to your CI"},{"body":" Circles are the main approach related to the new deploy concept brought by Charles. It enables user group creation with several characteristics and promotes simultaneous application tests for a great number of possible users.\nCircles indicate client segmentation and also support the version management created for a specific audience.\nOnce the right people are chosen to have access to your release associated with a circle, Charles will generate a[ series of business or performance metrics] (https://docs.charlescd.io/reference/metrics/charles-metrics/). This information will give you better hypothesis results or even a better view on a feature in analysis and that will enable more assertive tests.\nHow to create circles? To create a circle, you just have to follow these steps:\n1. Click on Create Circle.\n2. Give a name to your circle.\n3. Define segmentation.\n4. [Optional] Implement a release.\nWhat is segmentation? Segmentations are a subset of characteristics or percentage values that you define to put all your users together in a circle. There are three ways to segment your users:\n By filling in information manually Through a CVS file importation. Through a percentage value related to the total amount of access to your application.  Segmentations fields Segmentations have the following fields that you have to fill:\n Key: it is the same value in the user’s identify request payload. Conditional: it is the logical implication that will condition your key and value. Value: they are the values in your base that can be used to make the segmentation logic.  Key and value The key and value fields are established based on the information that will be sent in the request, which identifies the circles where your user belongs to. For example, the payload below could represent the information you have about a client:\n{ \"id\": \"7f2926d5-ff08-4d49-96df-d4ba0fc07b52\", \"name\": \"Alice\", \"state\": \"MG\", \"city\": \"Uberlândia\", \"age\": \"47\", \"groupId\": \"a435bd12-ae82-48c8-b164-066d91ffe3a5\" } The keys used could be any of the ones sent in your application payload to the Charles' circle-matcher, such as id, name, state, city, age e groupId.\nYour payload and your keys must be the same.  Percentage The segmentation by percentage has the following field:\n Percentage: value that indicates the percentage (%) of the requests that will be directed to a circle. For example, in a scenario where there is a circle with a percentage of 10% for every 100 requests, approximately 10 will go to the circle.  The sum of the active circles' factors with segmentation by percentage should never exceed 100.\nIf it is equal to 100, it means that the Default circle will never be indicated by the Circle Matcher.\n This happens only to users that belong to a Default circle, meaning the users belonging to circles with manual or CSV segmentation will never be directed to circles with segmentation by percentage.\nIf in your configuration there are circles with segmentation by rules and circles with segmentation by percentage, see the Circle Matcher identification logic below:\n It verifies if the payload matches some segmentation circle by rules. If it does, these circles will be returned and the circle’s search is ended. If there isn’t any compatible circle and there are active circles with segmentation by percentage, a random number between 1 and 100 is drawn and if it is less than or equal to the circle’s factor, this one is returned. In case any of the previous steps finds a compatible circle, the Default’s circle id is returned.  Circle creation example See the example on how to create a circle below:\nThe best advantage to use segmentation is the possibility to combine logic with several attributes to create different audience categories and, in this way, use them on hypothesis tests.\nFor example, using the characteristics ‘profession’ and ‘region’, you are able to create a circle with engineers from the Brazilian north region, another one with engineers from the southeast, and the third one with all Brazilian engineers.\n Manual segmentation On this kind of segmentation, you define the logic the circle will follow to build a match with predetermined characteristics.\nThese characteristics can be defined based on the following logic:\n Equal to Not Equal Lower Than Lower or equal to Higher than Higher or equal to Between Starts With  See some examples below:\nSegmentation by CSV importation This segmentation is used only in the first CSV column to create rules. The first line in the first column must contain the key name and the same one must be informed on the key field.\nAfter you have finished the file upload and saved the configuration, an overview will show up demonstrating how your segmentation is:\nThis way allows you to extract from an external client’s IDs base, a specific profile and import them directly on Charles. When a .csv file is imported and if it contains some empty lines, it will occur an importation error, because empty segments are not allowed.\nOR is the only logic operator supported on this segmentation.  Segmentation by percentage It is a kind of segmentation that distributes to the circles the number of requests not filtered in a manual segmentation. These requests are delivered, proportionally between configured circles and the default circle. The value of the percentage for each circle is defined between 0 and 100, and the sum of all active circles cannot exceed 100%.\nSegmentation by percentage example Suppose you have created two circles with percentage:\n Circle A, with 15%. Circle B, with 26%.  Now, the algorithm for identification draws a number between 1 and 100, and after that, it analyzes:\n If the number is less than or equal to 15, circle A is returned. If the number is bigger than 15 and less than or equal to 41 (15 + 26), circle B is returned. If the number is bigger than 41, the Default circle is returned.  If there isn’t a configured circle or an active one, the available amount will be 100%, like the image below:\nIf you have, for example, three active circles by percentage and each one of them have a 30% value, the available amount for your new circle will be 10%, see below:\nAfter the segmentation is created, the available percentage will be only altered if a new release is deployed for that circle, and then it will become active.\nIf, for example, the percentage hits the available 100%, it is necessary to change or remove the configured active circles in order to make more space, after that you are able to create a new circle.\nHow to get my circle’s identifier? Once your circle is created, even without the configuration, it already has a single identifier.\nTo get this information, select the workspace you want, and then on the left menu, click on Copy ID.\nActive and inactive circles The existence of releases defines if a circle is active or not, which are the implemented versions for user segmentation. Therefore, active circles have implemented releases while the inactive circle doesn’t have any.\nHow to integrate circle with services? Once the circle to which the user belongs is detected, this information must be passed on to all next requests through the x-circle-idparameter on the header. Charles detects by the circle’s ID which application version a determined request must be forward. Check out how it works below:\nAt some point during the interaction of the user and your application (App1), for example, the login - the Identify service of charles-circle-matcher - must be triggered to get the circle.\nBy that, the ID must be passed on as a value in the x-circle-id parameter located on the header of all next requests of your services (App2). Charles is responsible to disseminate this information because when it’s received on Kubernetes, it will be used to redirect the request to a corresponding release version associated with a circle.\nIf the x-circle-id is not passed on, all the requests will be redirected to Default versions, which means it will use the standard releases of your applications, without a specific segmentation.\nA mix of services with different versions of my release We will give an example of a specific scenario where your environment has two services: Application A and Application B and your circles must use the following versions:\nSo, the redirect logic using x-circle-id will be:\n The user sends to the header: x-circle-id=\"QA Circle\". In this circle, the request will be redirected to an X version of the service on Application A and the Y version of the service on Application B. The user sends to the header: x-circle-id=”Dev Circle”. In this circle, the request will be redirected to the Z version of the service on Application A and Z version of the service on Application B.  How to route your circles with Kubernetes Clusters? Charles involves Kubernetes and Istio on traffic routing. Let’s think about a scenario where there are two circles:\n Campinas residents (identify by ID 1234); Belo Horizonte’s residents (identify by ID 8746).  Both circles were implemented with service releases called ‘application’, but with different versions:\n Campinas' residents (1234): version 2, v2. Belo Horizonte’s residents (8746): version 3, v3.  Besides that, there is a default (v1) version for users that don’t fit in any specific circle.\nLet’s supposed that, to make a request to identify a user, an ID 8756 is returned. This information will be passed by the next service interaction through the header x-circle-id. The image below shows how Charles uses the internal resources to route the correct release.\nWhen performing a version implementation in a circle, Charles makes all the configurations so that the routing is correctly done. To understand better how this works, let’s use a scenario where a request comes from the service outside the stack, see the image above.\nThe request will be received by Ingress, which performs all the routing control to the service mesh.\n Once the request entry is allowed, Virtual Service inquiries the traffic routing rules to be applied on the addressed host. In this case, the evaluation happens throughx-circle-id header specification, in a way that the traffic corresponds to the application service. Besides the service, it is also necessary to know which subset is defined on the register. This verification is made on Destination rules. The traffic redirect is performed based on previous information until it gets to the service version. If the x-circle-id is not informed, there is a rule defined by Virtual Service that will forward to the default version (v1).  ","excerpt":" Circles are the main approach related to the new deploy concept …","ref":"/reference/circles/","title":"Circles"},{"body":" Os círculos são o principal diferencial do novo conceito de deploy trazido pelo Charles. Ele possibilita a criação de grupos de usuários a partir de diversas características e, dessa forma, promove testes simultâneos de aplicações para o maior número possível de usuários.\nAlém de indicar as segmentações de clientes, os círculos também auxiliam na gestão de versões implantadas para este público.\nUma vez escolhidas as pessoas certas para terem acesso à sua release associada ao círculo, o Charles irá gerar uma série de métricas de negócio ou desempenho. Essas informações te darão maior visibilidade dos resultados de uma hipótese ou feature em análise, possibilitando testes mais assertivos.\nComo criar círculos? Para você criar um círculo, siga os seguintes passos:\n1. Clique em Create Circle.\n2. Dê um nome ao seu círculo.\n3. Defina uma segmentação.\n4. [Opcional] Implante uma release.\nO que é uma segmentação? As segmentações são um conjunto de características ou um valor percentual que você define para agrupar seus usuários nos círculos. Existem três maneiras de segmentar seus usuários:\n Por meio do preenchimento de regras de forma manual. Por meio da importação de um arquivo CSV. Por meio de um valor de porcentagem em relação ao total de acessos à aplicação  Campos de uma segmentação As segmentações manuais possuem os seguintes campos:\n Chave: é o mesmo valor presente como chave payload da requisição de identificação do usuário. Condição: é a implicação lógica que condicionará sua chave e seu valor. Valor: são os valores existentes na sua base que poderão ser utilizados para compor a lógica de segmentação.  Chave e valor Os campos chave e valor são estabelecidos com base nas informações que serão enviadas na requisição que identifica os círculos aos quais o seu usuário pertence. Por exemplo, considere que o seguinte payload representa as informações que você possui do seu cliente:\n{ \"id\": \"7f2926d5-ff08-4d49-96df-d4ba0fc07b52\", \"name\": \"Alice\", \"state\": \"MG\", \"city\": \"Uberlândia\", \"age\": \"47\", \"groupId\": \"a435bd12-ae82-48c8-b164-066d91ffe3a5\" } As chaves utilizadas podem ser qualquer uma enviada no payload da sua aplicação ao circle-matcher do Charles, como: id, name, state, city, age e groupId.\nO seu payload e as chaves devem ser iguais.  Porcentagem A segmentação por porcentagem possui o seguinte campo:\n Porcentagem: valor que indica o percentual (%) das requisições que serão direcionadas para um círculo. Por exemplo, em um cenário que exista um circulo com porcentagem de 10%, a cada 100 requisições, aproximadamente 10 serão direcionadas para o círculo.  A soma dos fatores dos círculos ativos com segmentação por porcentagem nunca deve ultrapassar 100.\nCaso seja igual a 100, significa que o círculo Default jamais será indicado pelo Circle Matcher.\n Esse direcionamento é feito somente para usuários que pertencem ao círculo Default ou aos círculos com segmentação de porcentagem. Os usuários que pertencem ao círculos com segmentação por regras, seja manual ou por CSV, nunca serão direcionados para círculos com segmentação por porcentagem.\nSe na sua configuração existir círculos com segmentação por regras e círculos com segmentação por porcentagem, veja abaixo a lógica de identificação no Circle Matcher:\n Verifica se o payload faz match com algum círculo de segmentação por regras. Caso positivo, este(s) círculo(s) será(ão) retornado(s) e a busca pelos círculos é finalizada. Se não encontrar nenhum círculo compatível e existir círculos ativos com segmentação por porcentagem, um número aleatório entre 1 e 100 é sorteado e se ele for menor ou igual ao fator do círculo, este é retornado. Caso nenhum dos passos anteriores encontre um círculo compatível, o id do círculo Default é retornado.  Exemplo de criação de círculo Veja abaixo um exemplo de como criar um círculo:\nUma grande vantagem de utilizar as segmentações é a possibilidade fazer combinações lógicas entre vários atributos para criar diferentes categorias de públicos e, dessa forma, utilizá-los nos testes das hipóteses.\nPor exemplo, a partir das características “age” e “state”, é possível criar círculos por faixas etárias por região.\n Segmentação manual Nesta segmentação, você define as lógicas que o círculo deve seguir para compor uma combinação com usuários que atendam às características pré-determinadas.\nEssas características podem ser definidas com base nas lógicas de:\n Equal to Not Equal Lower Than Lower or equal to Higher than Higher or equal to Starts With  Veja alguns exemplos:\nSegmentação por importação de CSV Nessa modalidade, é utilizada apenas a primeira coluna do CSV para criar as regras. Sendo assim, a primeira linha da primeira coluna deve conter o nome da chave e a mesma deve ser informada no campo key:\nDepois de ter feito o upload do arquivo e salvado as configurações, aparecerá um overview demonstrando como está sua segmentação:\nEssa segmentação permite, por exemplo, extrair de uma base externa de IDs dos clientes um perfil específico e importá-los direto na plataforma do Charles. Quando um arquivo .csv é importado e se ele conter alguma linha em branco, ocorrerá um erro da importação, pois não é permitido a criação de segmentos dessa forma.\nO único operador lógico suportado nesta segmentação é o OR (Ou).  Segmentação por porcentagem É o tipo de segmento que distribui aos círculos a quantidade total de requisições que não foram filtradas em alguma segmentação manual. Essas requisições são entregues, de maneira proporcional, entre o círculos configurados para essa segmentação e o círculo default.\nO valor da porcentagem para cada círculo é definido entre 0 e 100, e a soma de todos os círculos ativos não pode ultrapassar 100%.\nExemplos de segmentação por porcentagem Supondo que você criou dois círculos com porcentagem:\n O círculo A, com 15% O círculo B, com 26%.  A partir daí, o algoritmo para identificação sorteia um número entre 1 e 100 (inclusive), e em seguida, é feita a seguinte análise:\n Se o número for menor ou igual a 15, é retornado o círculo A. Se o número for maior que 15 e menor ou igual a 41 (15 + 26), é retornado o círculo B. Se o número for maior que 41, é retornado o círculo Default.  Se não houver nenhum círculo configurado ou ativo, a quantidade disponível será de 100%, como na imagem abaixo:\nSe você, por exemplo, possui três círculos ativos por porcentagem e cada um tem o valor de 30% , a quantidade disponível para seu novo círculo será de 10%. Veja abaixo:\nDepois que a segmentação é criada, o percentual disponível só será alterado caso uma release seja implantada para aquele círculo e ele se torne ativo.\nSe, por exemplo, a porcentagem atingir os 100% disponíveis, é necessário alterar ou remover os círculos ativos e configurados para que haja espaço para você criar um novo círculo.\nComo obter o identificador do meu círculo? Assim que seu círculo é criado, mesmo sem a definição das configurações, ele já possui um identificador único.\nPara obter essa informação, siga estes passos:\n Selecione o círculo Clique em “default” E, no menu à esquerda, clique em Copy ID  Círculos ativos e inativos O que define se um círculo é ativo ou não, é a existência de releases, isto é, de versões implantadas para aquela segmentação de usuários. Por isso, os círculos ativos são os que possuem releases implantadas, enquanto os círculos inativos ainda não possuem nenhuma.\nComo integrar círculos com serviços? Uma vez detectado o círculo ao qual o usuário pertence, essa informação deve ser repassada para todas as próximas requisições através do parâmetro x-circle-id no header. Isso acontece porque o Charles detecta pelo ID do círculo para qual versão da aplicação uma determinada requisição deve ser encaminhada. Vejamos o exemplo abaixo:\nNa prática, em algum momento durante a interação do usuário com a sua aplicação (App1) - por exemplo, o login - o serviço Identify do circle-matcher deverá ser acionado para obter o círculo.\nCom isso, o ID deve ser repassado como valor no parâmetro x-circle-id localizado no header de todas as próximas chamadas dos seus serviços (App2). O Charles é responsável por propagar essa informação porque quando recebida no Kubernetes, será utilizada para redirecionar a requisição para a versão correspondente à release associada ao círculo.\nCaso o x-circle-id não seja repassado, todas as requisições serão redirecionadas para versões Default, ou seja, para releases padrões das suas aplicações sem uma segmentação específica.\nMescla de serviços com versões diferentes na minha release Para facilitar o entendimento, vamos exemplificar com um cenário onde o seu ambiente possui dois serviços: Aplicação A e Aplicação B e os seus círculos devem fazer o uso das seguintes versões:\nSendo assim, a lógica de redirecionamento utilizando o **x-circle-id**será:\n O usuário envia no header: x-circle-id=\"Círculo QA\". Nesse círculo, a chamada será redirecionada para a versão X do serviço Aplicação A e a versão Y do serviço Aplicação B. O usuário envia no header: x-circle-id=”Circulo Dev”. Nesse círculo, a chamada será redirecionada para a versão Z do serviço Aplicação A e a versão Z do serviço Aplicação B.  Como rotear círculos com cluster de Kubernetes? O Charles envolve o Kubernetes e o Istio no roteamento de tráfego, considere o seguinte cenário onde existe dois círculos:\n Moradores de Campinas (identificado pelo ID 1234); Moradores de Belo Horizonte (identificado pelo ID 8746).  Em ambos os círculos foram implantadas releases do serviço chamado “application”, mas com versões diferentes:\n Moradores de Campinas (1234): utiliza a versão v2. Moradores de Belo Horizonte (8746): utiliza a versão v3.  Além disso, existe uma versão default (v1) para usuários que não se encaixam em algum círculo específico.\nSuponha que, ao realizar a requisição para identificação do usuário, seja retornado o id 8756. Com isso, essa informação deverá ser repassada nas próximas interações com serviços através do header x-circle-id. A imagem abaixo retrata como o Charles utiliza internamente os recursos para rotear a release correta:\nAo realizar a implantação de uma versão em um círculo, o Charles realiza todas as configurações para que o roteamento seja feito da maneira correta. Para entender melhor como ele acontece, vamos utilizar um cenário onde uma requisição vem de um serviço fora da stack, como mostra na figura acima.\nA requisição será recebida pela Ingress, que realiza o controle do tráfego para a malha de serviços.\n Uma vez permitida a entrada da requisição, o Virtual Service consulta o conjunto de regras de roteamento de tráfego a serem aplicadas no host endereçado. Nesse caso, a avaliação acontece através da especificação do header x-circle-idde maneira que o tráfego corresponda ao serviço “application”. Além do serviço, também é necessário saber qual subconjunto definido no registro. Essa verificação é feita no __Destination Rules. O redirecionamento do tráfego é realizado com base nas informações anteriores, chegando então à versão do serviço. Caso o x-circle-id não seja informado, existe uma regra definida no Virtual Service que irá encaminhar para a versão padrão (v1).  ","excerpt":" Os círculos são o principal diferencial do novo conceito de deploy …","ref":"/pt/refer%C3%AAncia/c%C3%ADrculo/","title":"Círculo"},{"body":"","excerpt":"","ref":"/reference/","title":"Reference"},{"body":"","excerpt":"","ref":"/pt/refer%C3%AAncia/","title":"Referência"},{"body":" Circle Matcher is a resource that allows you to validate if your circles are incoherent segmentations. You can also use it in your applications to determine in which circle your users fit better.\nOne good practice is to always make this identification when a user logs in to the application. However, this can be changed according to your business needs.  For more information on how to configure your Circle Matcher in a workspace, see Defining Workspace section\nHow the circle identification is made?  The application searches all its databases __for circles with the same informed rules in the requests. In case there isn’t a compatible circle with the informed rules, Circle Matcher verifies if the user will be selected with the segmentation by percentage through its algorithm that uses selection probability. To finish, if any circle fits in, Circle Matcher will return the default circle registered.  Identifying circles through CharlesCD Once you start using the interface, it’s possible to notice that there are two ways to perform the circle identification. For that, access the Circles menu inside a workspace and select the icon indicated below:\nThe way to make this validation are:\nYou add manually keys and values to define the characteristics of a user test. Based on that, once you run the Try, you will receive all the circles related to this user.\nIf you pass some information that is off the preconfigured logic conditions in the circles, the system will return indicating that the user is on the Default circle, on the standard version of your application.  Circle identification through API You can integrate with your applications the Identify resource on the charles-circle-matcher module to detect the circles the user belongs to.\nFor example, considering the use of the parameters below to segment:\nOnce you send the identification request with some information, compatible circles will be returned.\nPOST Identify https://api.charlescd-circle-matcher.com/identify This request used to identify circles based on the user’s characteristicsEsta requisição implanta a release composta criada anteriormente em um círculo.\nRequest Body Parameters: All required:\n   Key Type Description     requestData object { “state”: “NY”, “profession”: “Lawyer”, “age”: 46, “city”: “Stony Brook”   workspaceId String UUID    Response { \"circles\": [ { \"id\": \"6577ae92-648c-11ea-bc55-0242ac130003\", \"name\": \"NY Lawyers\" }, { \"id\": \"6577b112-648c-11ea-bc55-0242ac130003\", \"name\": \"Stony Brook's Citizens\" } ] } As the example above shows, there are circles with the given information of the user, which means that charlescd-circle-matcher will return a list with all the circles. Here, there are two circles that fit with this description: NY Lawyers e Stony Brook’s Citizens. The order of the circles returned will be by the date of creation, so the newest circle created will be the first of the list.\nThe request body is totally flexible, but it’s good to remember that the keys must have the same nomenclature defined by segmentation’s rules of the circle. See the case below:\nThe Stony Brook’s Citizens circle was created to identify users that contain as one of its characteristics the key city and the exact value London. That means that this user won’t be listed if you send a request to Identify and inform on the request body the information presented on the example below:\nPOST Identify https://api.charlescd-circle-matcher.com/identify This request implants the release created before in a circle.\nRequest Body Parameters: All required:\n   Key Type Description     requestData object { “age”: 46, “city”: “London” }   workspaceId String UUID    Response { \"circles\": [ { \"id\": \"6577ae92-648c-11ea-bc55-0242ac130003\", \"name\": \"Default\" } ] } ","excerpt":" Circle Matcher is a resource that allows you to validate if your …","ref":"/reference/circle-matcher/","title":"Circle Matcher"},{"body":" O Circle Matcher é um recurso que permite você validar se os seus círculos estão com segmentações coerentes. Você também pode utilizá-lo em suas aplicações para determinar em qual círculo os seus usuários se encaixam.\nUma boa prática é realizar essa identificação sempre que o usuário faz login na aplicação. Porém, isso pode ser alterado de acordo com a necessidade da sua regra de negócio.  Para mais informações de como configurar seu Circle Matcher em um workspace,veja a seção Definindo um Workspace.\nComo é realizada a identificação de círculos?  A aplicação realiza uma busca em toda a sua base de dados por círculos que tenham as mesmas regras informadas na requisição. Caso não haja um círculo compatível com as regras informadas cadastrado, o Circle Matcher verifica se o usuário irá ser selecionado pelos círculos com segmentação por porcentagem através de seu algoritmo que utiliza probabilidade na seleção. Para finalizar, se nenhum círculo se encaixar, o Circle Matcher irá retornar o círculo default cadastrado.  Identificando círculos através do CharlesCD Ao utilizar a interface é possível perceber que existe uma forma de realizar a identificação dos círculos. Para isto, acesse o menu Circles dentro de um workspace e selecione o ícone indicado abaixo:\nVocê adiciona manualmente chaves e valores que definem as características de um usuário de teste. E, com base nisso, ao executar o Try, você receberá todos os círculos que ele se encaixa.\nSe você passar informações que estejam fora das condições lógicas configuradas nos círculos, o sistema irá retornar que aquele usuário está no círculo Default, ou seja, na versão padrão da sua aplicação.  Identificação de círculos por meio da API Você pode integrar nas suas aplicações o recurso Identify do módulo circle-matcher para detectar os círculos que o seu usuário pertence.\nPor exemplo, dada a utilização dos seguintes parâmetros ao segmentar:\nAo realizar a requisição de identificação com as seguintes informações, círculos compatíveis serão retornados.\nPOST Identify https://api.charlescd-circle-matcher.com/identify Esta requisição implanta a release composta criada anteriormente em um círculo.\nRequisição Body Parameters: Todos obrigatórios:\n   Key Tipo Descrição     requestData object { “state”: “NY”, “profession”: “Lawyer”, “age”: 46, “city”: “Stony Brook”   workspaceId String UUID    Resposta { \"circles\": [ { \"id\": \"6577ae92-648c-11ea-bc55-0242ac130003\", \"name\": \"NY Lawyers\" }, { \"id\": \"6577b112-648c-11ea-bc55-0242ac130003\", \"name\": \"Stony Brook's Citizens\" } ] } Como nesse exemplo existem círculos correspondentes com as informações sobre o usuário, o **charlescd-circle-matcher**retorna uma lista com eles. Aqui, dois círculos se encaixaram: NY Lawyers e Stony Brook’s Citizens. A ordem de retorno dos círculos é feita pela data de criação, portanto o círculo mais recente será o primeiro da lista.\nO corpo da requisição é totalmente flexível, porém vale lembrar que as chaves devem ter a mesma nomenclatura definida nas regras de segmentação do círculo. Veja no caso a seguir:\nO círculo Stony Brook’s Citizens foi criado para a identificar usuários que tenham como característica a chave city e o exato valor London. Sendo assim, ele não estará na listagem ao realizar uma requisição para o Identify caso seja informado o corpo da requisição como no exemplo abaixo:\nPOST Identify https://api.charlescd-circle-matcher.com/identify Esta requisição implanta a release composta criada anteriormente em um círculo.\nRequisição Body Parameters: Todos obrigatórios:\n   Key Tipo Descrição     requestData object { “age”: 46, “city”: “London” }   workspaceId String UUID    Resposta { \"circles\": [ { \"id\": \"6577ae92-648c-11ea-bc55-0242ac130003\", \"name\": \"Default\" } ] } ","excerpt":" O Circle Matcher é um recurso que permite você validar se os seus …","ref":"/pt/refer%C3%AAncia/circle-matcher/","title":"Circle Matcher"},{"body":" Um grupo de usuários pode representar um time ou até mesmo um subconjunto de pessoas baseado em suas habilidades.\nPor exemplo, em um time muito grande, as permissões de acesso ao Charles poderiam se diferenciar de acordo com a posição de seus membros, você teria os seguintes grupos:\n Desenvolvedores do Produto X. QAs do Produto X. Data Analysts do Produto X.  Porém, se todos do time tiverem a mesma permissão, você pode criar apenas um grupo com todos os usuários:\n Time do Produto X.  Permissões para o Grupo de Usuários no Workspace As permissões do Charles são dadas aos grupos de usuários quando você os associa a um workspace.\nOs seguintes perfis são suportados:\n Mantenedor: pode acessar e editar todas as configurações do workspace. Ele pode realizar implantações, e também tem a permissão para criar, editar e deletar círculos e módulos. Desenvolvedor: possui acesso para realizar implantações e também pode criar, editar, deletar círculos e módulos. Analista: pode visualizar módulos. Possui permissão para criar, editar e deletar círculos. Leitor: pode visualizar círculos e módulos.  Mapa de Permissões Segue abaixo as permissões vinculadas a cada perfil:\n   Módulos Ação Maintainer Developer Analyst Reader     Usuários Criar        Editar        Deletar        Visualizar       Grupo de usuários Criar        Editar        Deletar        Visualizar       Workspace Criar        Configurar ✔       Deletar        Visualizar ✔ ✔ ✔ ✔   Circle Criar/Editar/Deletar ✔ ✔ ✔     Visualizar ✔ ✔ ✔ ✔   Modules Criar/Editar/Deletar ✔ ✔      Visualizar ✔ ✔ ✔ ✔   Deploy Fazer deployments ✔ ✔      ","excerpt":" Um grupo de usuários pode representar um time ou até mesmo um …","ref":"/pt/refer%C3%AAncia/grupo-de-usu%C3%A1rios/","title":"Grupo de Usuários"},{"body":" A user group can represent a team or even a subset of people based on their skills.\nFor example, a big team would have different Charles access permissions according to their job position, you could have these groups:\n Product X developers; Desenvolvedores do Produto X. Product X QAs; Product X Data Analysts.  However, if everyone in a team has the same permission, you are able to create only one group with its users.\n Product X Team.  Permissions for user groups in your workspace Charles permissions are given to a user group when you associate them with a workspace.\nThe following profiles are available:\n  Maintainer: can access and edit all workspace configurations. They can do implementations and create, edit and delete circles and modules.\n  Developer: they have access to do implementations\nand also create, edit and delete circles and modules.\n  Analyst: is able to view modules. They have permission to edit and delete circles and modules. And also view the modules' configuration.\n  Reader: is able to view circles and modules.\n  Permissions map See below the permission given to each profile:\n   Modules Action Maintainer Developer Analyst Reader     Users Create        Edit        Delete        View       User Groups Create        Edit        Delete        View       Workspace Create        Configure ✔       Delete        View ✔ ✔ ✔ ✔   Circle Create/Edit/Delete ✔ ✔ ✔     View ✔ ✔ ✔ ✔    View ✔ ✔ ✔ ✔   Modules Create/Edit/Delete ✔ ✔      View ✔ ✔ ✔ ✔   Deploy Make deployments ✔ ✔      ","excerpt":" A user group can represent a team or even a subset of people based on …","ref":"/reference/users-groups/","title":"Users Groups"},{"body":" On the default installation, you have the option which Charles manages your users' authentications on the platform. However, if you already have an Identity Manager (IDM) and want to use it, just configure it during Charles' installation.\nConfiguring IDM Oncharlescd/install/helm-chart/values.yaml, change the values on the modules:\nmoove internalIdmEnabled: false  internalIdmEnabled : Refers whether moove must use the default IDM or not. To inform that you will use an external IDM, add the valuefalse.  ui authUri: http://charles.info.example/keycloak isIdmEnabled: \"1\" idmLoginUri: /protocol/openid-connect/auth idmLogoutUri: /protocol/openid-connect/logout idmRedirectHost: http://charles.info.example  authUri: Stores the base endpoint of your IDM that will make authentication. For example, if you were going to use Google, the value would be: https://accounts.google.com/o/oauth2/v2/auth?. isIdmEnabled: refers if the customized UI will make the authentication. In this case, 0 indicates that it will use the default and 1 a customized IDM. idmLoginUri: it is your authUri base complement, it’s used to indicate which endpoint will log in. idmLogoutUri: it is your authUri base complement, it’s used to indicate which endpoint will logout. idmRedirectHost: this field you inform Charles' URL where the user will be redirected right after successful authentication.  nginx idm: endpoint: http://charlescd-keycloak-http/ port: 443 path: keycloak/auth/realms/charlescd/.well-known/openid-configuration  idm.endpoint: this field represents the hostname of the IDM that you’re using with Charles. idm.port: this field represents the port of the IDM that you’re using with Charles. idm.path: this field represents the path that will be used by the envoy to validate your token. For this token validation, Charles uses the openID /userinfo endpoint.  ","excerpt":" On the default installation, you have the option which Charles …","ref":"/reference/identity-manager/","title":"Identity Manager"},{"body":" Na instalação padrão, você tem a opção para que o próprio Charles gerencie a autenticação dos seus usuários na plataforma. Entretanto, caso você já tenha um Identity Manager (IDM) e queira utilizá-lo, basta fazer a sua configuração durante a instalação do Charles.\nConfigurando o IDM Emcharlescd/install/helm-chart/values.yaml, altere os valores nos módulos:\nmoove internalIdmEnabled: false  internalIdmEnabled : Referencia se o moove deve utilizar o IDM padrão ou não. Para informar que você utilizará um IDM externo, informe o valor false.  ui authUri: http://charles.info.example/keycloak isIdmEnabled: \"1\" idmLoginUri: /protocol/openid-connect/auth idmLogoutUri: /protocol/openid-connect/logout idmRedirectHost: http://charles.info.example  authUri: Armazena o endpoint base do seu IDM que fará a autenticação. Por exemplo, se você fosse utilizar o Google, o valor seria: https://accounts.google.com/o/oauth2/v2/auth?. isIdmEnabled: referencia se o UI deverá utilizar um IDM personalizado para realizar a autenticação. Neste caso, 0 indica que utilizará o padrão e 1 um IDM personalizado. idmLoginUri: complemento da sua authUri base, é utilizada para indicar qual o endpoint para realizar o login. idmLogoutUri: complemento da sua authUri base, é utilizada para indicar qual o endpoint para realizar o logout. idmRedirectHost: neste campo é informada a URL do Charles que o usuário deverá ser redirecionado logo após uma atenticação bem sucedida.  nginx idm: endpoint: http://charlescd-keycloak-http/ port: 443 path: keycloak/auth/realms/charlescd/.well-known/openid-configuration  idm.endpoint: o nginx que vem na instalação do Charles fará a validação do token informado durante as requisições, para isso, é necessário informar este endpoint. idm.port: este campo representa a porta do IDM que você está usando com o Charles. idm.path: este campo representa o path que será usado pelo envoy para validar o seu token. Para essa validação de token, o Charles utiliza o openid/userinfo endpoint.  ","excerpt":" Na instalação padrão, você tem a opção para que o próprio Charles …","ref":"/pt/refer%C3%AAncia/identity-manager/","title":"Identity Manager"},{"body":"","excerpt":"","ref":"/reference/registry/","title":"Registry"},{"body":" Why do you have to configure a Registry? One of the main points for Charles to work is to know where are the images of your applications. To do this, you are expected to store them in a docker registry and grant access to it.\nOnce you make this configuration, Charles is able to read your registry and do some actions like:\n Validates if the tag you are informing when deploying in a circle is valid; During the generation of a release through the board, villager uses this permission to search for the tag in the registry and ensure that it has been sent and can be used.  Charles is already integrated with some docker registries, choose one and add the information:\n","excerpt":" Why do you have to configure a Registry? One of the main points for …","ref":"/reference/registry/overview/","title":"Registry"},{"body":"","excerpt":"","ref":"/pt/refer%C3%AAncia/registry/","title":"Registry"},{"body":" Por que configurar o Registry?  ‌Um dos pontos para o Charles trabalhar é saber onde estão as imagens da sua aplicação. Para fazer isso, é esperado que você armazene-as em um docker registry e garanta o acesso a elas.\nUma vez que essa configuração foi feita, Charles está preparado para ler seu registro e fazer algumas ações, como:\n Confirmar se a tag informada quando um estiver fazendo um deploy em um círculo é válida. Usar essa permissão durante a geração de uma release por meio do quadro villager para procurar pela tag no registry e garantir que ela seja enviada e usada.  ‌Charles já está integrado com alguns docker registries, escolha um e adicione as informações necessárias:\n","excerpt":" Por que configurar o Registry?  ‌Um dos pontos para o Charles …","ref":"/pt/refer%C3%AAncia/registry/visao-geral/","title":"Visão Geral"},{"body":" Enter the data below to grant Charles access to your Azure Container Registry:\n Name: custom name to identify your configuration; Your registry’s URL: the URL pattern for your registry is https://registry-name.azurecr.io/ Username: this is the service’s entity ID that will be used by Kubernetes to access the registry; Password: service’s entity password.  If you have any doubts about how to proceed or find the information above, you can visit Azure Container Registry documentation.\nThe connection test feature makes sure that the credentials informed are valid.  ","excerpt":" Enter the data below to grant Charles access to your Azure Container …","ref":"/reference/registry/azure-container-registry/","title":"Azure Container Registry"},{"body":" Informe os dados abaixo para conceder acesso a Charles ao seu Azure Container Registry:\n Nome: esse nome representará sua configuração no Charles; URL do seu registry: a URL para o seu registry padrão é https://registry-name.azurecr.io/ Username: ID da entidade de serviço que será usada pelo Kubernetes para acessar o registro; Password: senha da entidade de serviço.  Em caso de dúvidas para encontrar essas informações, sugerimos a documentação da Azure Container Registry.\nA funcionalidade de Connection Test garante que as credenciais informadas são válidas.  ","excerpt":" Informe os dados abaixo para conceder acesso a Charles ao seu Azure …","ref":"/pt/refer%C3%AAncia/registry/azure-container-registry/","title":"Azure Container Registry"},{"body":" Enter the data below to grant Charles access to your Docker Hub:\n Name: custom name to identify your configuration; Your registry’s URL: Docker Hub URL (https://registry.hub.docker.com); Username: add your dockerid; Password: your Dockerhub password or access token. See below how to generate one:   Access your docker account; Go to account settings; Select the option Security; Click on “new access token” button and copy the generated token.  The connection test feature makes sure that the credentials informed are valid.  ","excerpt":" Enter the data below to grant Charles access to your Docker Hub: …","ref":"/reference/registry/docker-hub/","title":"Docker Hub"},{"body":" Informe os dados abaixo para conceder acesso a Charles ao seu Docker Hub:\nNome: esse nome representará sua configuração no Charles;\n URL do seu registry: a URL do seu Docker Hub https://registry.hub.docker.com; Username: adicione o seu dockerid; Password: a senha do seu Docker Hub ou o token de acesso. Veja a baixo como gerar:   Acesse sua conta docker; Vá em configurações (Account settings); Selecione a opção Security; Clique em new access token e copie o token gerado.  A funcionalidade de Connection Test garante que as credenciais informadas são válidas.  ","excerpt":" Informe os dados abaixo para conceder acesso a Charles ao seu Docker …","ref":"/pt/refer%C3%AAncia/registry/docker-hub/","title":"Docker Hub"},{"body":" Enter the data below to grant Charles access to your Amazon ECR:\n Name: custom name to identify your configuration; Your registry’s URL: according to the convention, the URL pattern for your registry is: https://aws_account_id.dkr.ecr.region.amazonaws.com; Access Key: security information generated by AWS IAM; Secret Key: security information generated by AWS IAM; Region: the region where you are located.  If you have any doubts about how to proceed or find the information above, you can visit Amazon ECR documentation\nThe connection test feature makes sure that the credentials informed are valid.  ","excerpt":" Enter the data below to grant Charles access to your Amazon ECR: …","ref":"/reference/registry/ecr/","title":"ECR"},{"body":" Informe os dados abaixo para conceder acesso a Charles ao seu Amazon ECR:\nNome: esse nome representará sua configuração no Charles;\n URL do seu registry: segundo a convenção, a URL para o seu registry padrão é https://aws_account_id.dkr.ecr.region.amazonaws.com; Access Key: informação de segurança gerada pela AWS ECR; Secret Key: informação de segurança gerada pela AWS ECR; Region: a região de onde você está operando.  Em caso de dúvidas para encontrar essas informações, acesse a documentação da Amazon ECR.\nA funcionalidade de Connection Test garante que as credenciais informadas são válidas.  ","excerpt":" Informe os dados abaixo para conceder acesso a Charles ao seu Amazon …","ref":"/pt/refer%C3%AAncia/registry/ecr/","title":"ECR"},{"body":" Enter the data below to grant Charles access to your Google Cloud Registry:\n Name: custom name to identify your configuration; Your registry’s URL: your GCR’s URL like(%20https://gcr.io)https://gcr.io; Project ID: access Google Cloud Platform, select your project and copy the id; JSON key: add the generated JSON key. For more information on how to generate your JSON key.  If you have any doubts about how to proceed or find the information above, you can visit Google Container Registry documentation.\nThe connection test feature makes sure that the credentials informed are valid.  ","excerpt":" Enter the data below to grant Charles access to your Google Cloud …","ref":"/reference/registry/gcr/","title":"GCR"},{"body":" Informe os dados abaixo para conceder acesso a Charles ao seu Google Cloud Registry:\n Nome: esse nome representará sua configuração no Charles; URL do seu registry: a URL do seu GCR, como https://gcr.io; Project ID: acesse o Google Cloud Platform, selecione seu projeto e copie o id; JSON key: adicione o JSON key gerado. Para mais informações de como gerar seu json key, acesse o tutorial.  Em caso de dúvidas para encontrar essas informações, acesse a documentação da Google Container Registry.\nA funcionalidade de Connection Test garante que as credenciais informadas são válidas.  ","excerpt":" Informe os dados abaixo para conceder acesso a Charles ao seu Google …","ref":"/pt/refer%C3%AAncia/registry/gcr/","title":"GCR"},{"body":" Releases são as versões de uma aplicação. Diferente de outras formas de deploy, em que as releases geralmente passam por diversos ambientes até chegar ao de produção, no CharlesCD é possível que uma mesma release seja publicada para diferentes círculos.\nComo criar releases pelo Charles? Veja como criar releases no Charles:\n Por meio de imagens existentes no docker registry.  Essa forma oferece a flexibilidade necessária para casos em que é desejado que toda a parte de desenvolvimento e geração de artefatos estejam apartadas do CharlesCD.\nReleases por meio de imagens existentes no Docker Registry configurado Para criar uma release, é preciso que as imagens no Docker já estejam disponíveis no registry configurado para o módulo. Se esse requisito já estiver feito, basta clicar na opção Circles no menu do Charles e selecionar o círculo desejado para o deploy da release a ser criada.\nCaso o círculo esteja sendo criado neste momento, clique em Insert release e logo após em Create release. Se o círculo já existir, clique em Override release e depois em Create release.\nNa tela de criação de releases, preencha o nome e selecione um módulo e sua componente. No campo ao lado, todas as imagens disponíveis daquela componente serão listadas no registry. Selecione uma e se for necessário adicione mais módulos a release, clique em Add modules e repita o processo anterior. Quando todos os seus módulos estiverem cadastrados, clique em deploy.\nApós o deploy desta nova release, ela estará disponível para utilização em outros círculos a partir da opção “Search for existing releases”.\n","excerpt":" Releases são as versões de uma aplicação. Diferente de outras formas …","ref":"/pt/refer%C3%AAncia/release/","title":"Release"},{"body":" Releases are application versions. It is different from other ways of deployment that a release generally goes through lots of environments until they reach production. However, with CharlesCD it is possible that the same release will be published for different circles.\nHow to create releases with Charles? See how to create releases with Charles:\n Existing images on docker registry.  This one offers the flexibility needed if you want cases in which the generation of artifacts or the development process is apart from CharlesCD.\nReleases through existing images on configured Docker Registry To create a release without using the hypothesis board, it is necessary that the Docker images are already available on your configured registry for the module. If this requirement is done, just click on the circles ' option on Charles' menu and select the circle for a release deployment to be created.\nIf you are creating the circle at this moment, click on Insert release and then Create release. If the circle is already created, click on Override release and then Create release.\nOn the release creation screen, fill in the name and select one module and its component. On the field beside, all available images on that component will be listed on the registry. Select one and, if it’s necessary, add more modules to the release, clicking on Add module and repeat the previous process. When all your modules are registered, click on deploy.\nAfter deploying this new release, it will be available to use in other circles, just look into the ‘Search for existing releases’ option.\n","excerpt":" Releases are application versions. It is different from other ways of …","ref":"/reference/releases/","title":"Releases"},{"body":" What is it? A system token is an opaque string of characters that identifies a user or an application. It can be used by integration to call Charles C.D’s internal APIs.\nIf you want to integrate Charles into your deployment pipeline, you will need a permission system token to execute actions.  When you access Charles with the root profile, the “System Token” item will show up on the menu. This is the token management area where you can create new tokens, view the existing ones, revoke and recreate.\nHow can you create? To create a system token, you need to fill in three pieces of information:\n The name to identify the token; The workspaces it will have access to; Which permission scopes the token will be able to work in the workspaces.  Workspaces You have two options to choose the workspaces:\n Allow the token to have access to all workspaces:   Select specific workspaces:  Scopes The scopes define which actions a token can perform. You can create your token with one or more scopes. To do that, choose the best options below:\n Modules: full access (reading and writing) of the APIs referring to the modules.  Writing: access to create, update and delete modules Reading: access to read all modules.   Circles: full access (reading and writing) to the APIs referring to the circles.  Writing: access to create, update and delete circles. Reading: access to read all circles.   Deploy: full access (reading and writing) to circles release implementation. Maintenance: full access (reading and writing) to the workspaces' configurations.  How to copy a token? After you have finished customizing your token, don’t forget to copy it. It is not possible to copy this token again.\nHow can you revoke a token? You can revoke the token’s permissions, to do that, check out below:\n Access the token menu; Select the token; Click on Revoke Token option.  How can you generate a token again? If you lost the value of your token, it is possible to create it again with all the existing permissions. When you do that, the previous value is canceled and the new value is the only one valid. Check out the example below:\n On the top menu, click on “Regenerate\"; Confirm the action in the “Yes, regenerate token” button that will pop up; Done! A new token will be generated.  ","excerpt":" What is it? A system token is an opaque string of characters that …","ref":"/reference/system-token/","title":"System Token"},{"body":" O que é? Um token sistêmico é uma cadeia de caracteres opaca que identifica um usuário (ou aplicação). Ele pode ser utilizado por integrações para realizar chamadas nas APIs internas do Charles C.D.\nSe você deseja integrar o Charles ao seu pipeline de deployment, você irá precisar de um token sistêmico com permissionamento para executar as ações.  Quando você acessar o Charles com o perfil de root, o item “System Token” aparecerá no menu inicial Essa é a área gerencial dos tokens, onde você pode criar novos tokens, visualizar todos existentes, revogar e recriar.\nComo criar? Para criar um token sistêmico, você precisa preencher três informações:\n O nome que identificará o token; Os workspaces que ele terá acesso; Quais os escopos de permissionamento o token poderá atuar dentro dos workspaces.  Workspaces Para selecionar os workspaces, você terá duas opções:\n Permitir que o token tenha acesso a todos os worskspaces:   Selecionar workspaces específicos:  Escopos Os escopos definem quais as ações um token pode desempenhar. Você pode criar o seu token com um ou mais escopos. Para fazer isso, escolha entre as opções abaixo:\n Módulos: acesso completo (leitura e escrita) as APIs referentes aos módulos.  Escrita: acesso para criar, atualizar e deletar módulos. Leitura: acesso de leitura a todos os módulos.   Círculos: acesso completo (leitura e escrita) as APIs referentes aos círculos.  Escrita: acesso para criar, atualizar e deletar círculos. Leitura: acesso de leitura a todos os círculos.   Deploy: acesso completo (leitura e escrita) à implantação de releases nos círculos. Manutenção: acesso completo (leitura e escrita) as configurações dos workspaces.  Como copiar um token? Depois de finalizar o processo de personalização do seu token, não se esqueça de copiá-lo. Não é possível copiar esse token novamente.\nComo revogar um token? Para anular as permissões de um token, é só revogá-lo. Veja abaixo como fazer isso:\n Acesse o menu de visualização do token; Selecione o token; Clique na opção Revoke Token.  Como gerar um token novamente? Se você perdeu o valor do seu token, é possível recriá-lo com todas as permissões já existentes. Quando você faz isso, o valor anterior é cancelado e o novo valor é o único válido. Veja o exemplo abaixo:\n No menu superior, clique em “Regenerate” Confirme a ação no botão “Yes, regenerate token.” em pop-up que irá aparecer. Pronto! Um novo valor será gerado.  ","excerpt":" O que é? Um token sistêmico é uma cadeia de caracteres opaca que …","ref":"/pt/refer%C3%AAncia/token-sist%C3%AAmico/","title":"Token Sistêmico"},{"body":"","excerpt":"","ref":"/reference/metrics/","title":"Metrics"},{"body":" What are metrics? Metrics are indicators that allow you to quantify the performance and the status of the applications based on the analysis of exposed data from the own application and by the infrastructure tools.\nSee how to set up your metrics and how to use them below:\n","excerpt":" What are metrics? Metrics are indicators that allow you to quantify …","ref":"/reference/metrics/overview/","title":"Metrics"},{"body":"","excerpt":"","ref":"/pt/refer%C3%AAncia/m%C3%A9tricas/","title":"Métricas"},{"body":" As métricas são os indicadores que permitem você quantificar o desempenho e o status de suas aplicações a partir da análise de dados expostos pelas próprias aplicações e pelas ferramentas de infraestrutura. Com o Charles, você pode obter métricas de cada um dos seus círculos.\nVeja abaixo como habilitar e usar as métricas diponíveis no Charles:\n","excerpt":" As métricas são os indicadores que permitem você quantificar o …","ref":"/pt/refer%C3%AAncia/m%C3%A9tricas/visao-geral/","title":"Visão Geral"},{"body":" A configuração de métricas no Charles é realizada no Istio e no seu próprio provedor. Veja os detalhes abaixo.\nConfigurando Istio As métricas relacionadas às requisições de cada círculo podem ser quantificadas e expostas pelo Istio.\nA configuração pode ser feita a partir da versão =\u003e1.7 do Istio.  Configurando sua própria ferramenta de métricas Depois de habilitar o Istio, você precisa configurar sua ferramenta para que ela possa ler as métricas expostas.\nVeja abaixo os detalhes das ferramentas compatíveis com o Charles.\nPrometheus O Prometheus é uma ferramenta de código aberto focada em monitoramento e alertas. É considerada a principal recomendação para monitoramento do Cloud Native Computing Foundation, além de uma das principais ferramentas do mercado.\nSe quiser saber mais, veja a documentação do Prometheus.  É preciso configurar o Prometheus para que ele consiga ler e armazenar os dados das métricas habilitadas, conforme o tutorial que explicamos no início.\nPara fazer isso, é necessário adicionar o job abaixo para que leia a métrica gerada pelo Istio. Para configurar, edite o arquivo prometheus.yml no seu Prometheus configMap.\nÉ importante lembrar que, para que essas configurações funcionem, é necessário que seu Prometheus esteja no mesmo cluster de Kubernetes que o Istio e o restante das suas aplicações.  Basta adicionar o job abaixo para realizar a configuração.\nglobal:scrape_interval:15sscrape_timeout:10sevaluation_interval:15sscrape_configs:- job_name:charles-metricshonor_timestamps:truescrape_interval:5sscrape_timeout:5smetrics_path:/v1/metricsscheme:httpkubernetes_sd_configs:- role:endpointsnamespaces:names:- namespace1- namespace2relabel_configs:- separator:;regex:_meta_kubernetes_pod_label(.+)replacement:$1action:labelmap- source_labels:[__meta_kubernetes_pod_label_circleId]separator:;regex:(.*)target_label:circle_sourcereplacement:$1action:replace- source_labels:[__meta_kubernetes_pod_label_version]separator:;regex:(.*)target_label:versionreplacement:$1action:replace- source_labels:[__meta_kubernetes_pod_name]separator:;regex:(.*)target_label:pod_namereplacement:$1action:replace- job_name:kubernetes-podskubernetes_sd_configs:- role:podrelabel_configs:- action:keepregex:truesource_labels:- __meta_kubernetes_pod_annotation_pryometheus_io_scrape- action:replaceregex:(.+)source_labels:- __meta_kubernetes_pod_annotation_prometheus_io_pathtarget_label:__metrics_path__- action:replaceregex:([^:]+)(?::\\d+)?;(\\d+)replacement:$1:$2source_labels:- __address__- __meta_kubernetes_pod_annotation_prometheus_io_porttarget_label:__address__ - action:replacesource_labels:- __meta_kubernetes_namespacetarget_label:kubernetes_namespace- action:replacesource_labels:- __meta_kubernetes_pod_label_circleIdtarget_label:circle_source- action:replacesource_labels:- __meta_kubernetes_pod_label_componenttarget_label:destination_component - action:replacesource_labels:- __meta_kubernetes_pod_nametarget_label:kubernetes_pod_name- action:dropregex:Pending|Succeeded|Failedsource_labels:- __meta_kubernetes_pod_phase Mude o nome do namespace para um onde sua aplicação está deployada.  Para saber mais sobre o serviço de discovery do Prometheus e Kubernetes, acesse a documentação.  Metadados A partir de cada métrica, é possível extrair uma série de metainformações, ou seja, de atributos ou informações complementares a essas métricas e que podem ser obtidas com diversos tipos de filtros e análises.\n‌Cada métrica possui uma faixa de metadado que permite uma variedade de filtros e tipos de análises a serem criadas. Foram adicionados mais metadados ao Istio e ele são descritos na tabela abaixo:\n   Metadado Descrição Tipo     destination_component Valor presente na label “app” da POD que recebeu a requisição ou “unknown” se a informação não estiver presente. Texto   circle_source Label do círculo injetado em qualquer pod do Kubernetes. Texto   response_code O status HTTP da resposta daquela requisição. Número    Google Analytics O Google Analytics é um dos data sources que o Charles pode conectar para ler suas métricas.\nPara usá-lo no seu grupo de métricas, você precisa de:\n Uma conta Google e o Analytics configurado.  Se você quiser usar o Charles para analizar os dados do seu Google Analytics, você precisa adicionar uma nova métrica com a ID do circulo (renomeando como circle_source) na label da sua métrica.\nPara mais informações sobre o Google Analytics, acesse a documentação do Analytics.  ","excerpt":" A configuração de métricas no Charles é realizada no Istio e no seu …","ref":"/pt/refer%C3%AAncia/m%C3%A9tricas/configurando-as-m%C3%A9tricas/","title":"Configurando as métricas"},{"body":" Charles' metrics configuration is performed on Istio and on your own metrics provider. See more details below.\nIstio Configuration Metrics related to circle requests are quantified and exposed by Istio, so it’s necessary to configure it to get information about each circle.\nThe configuration in this section can be done starting with Istio =\u003e1.7 versions.  Configuring your metrics' tool After you finish your Istio configuration it is necessary to configure your metrics tool.\nSee below the details of the tools Charles will be able to read.\nPrometheus Prometheus is an open-source system for monitoring and alerting toolkit. It is the main monitoring recommendation on Cloud Native Computing Foundation\nIf you want to know more about Prometheus, check out Prometheus' documentation  In order for Prometheus to be able to read and store metrics data, you have to configure it.\nTo do so, it’s necessary to add the job below so it will read Istio’s generated metrics. Just configure by editing the prometheus.yml file into your Prometheus configMap.\nIt is important to remember that all these configurations consider that your Prometheus is on the same Kubernetes cluster as your Istio and the rest of your applications.  global:scrape_interval:15sscrape_timeout:10sevaluation_interval:15sscrape_configs:- job_name:charles-metricshonor_timestamps:truescrape_interval:5sscrape_timeout:5smetrics_path:/v1/metricsscheme:httpkubernetes_sd_configs:- role:endpointsnamespaces:names:- namespace1- namespace2relabel_configs:- separator:;regex:_meta_kubernetes_pod_label(.+)replacement:$1action:labelmap- source_labels:[__meta_kubernetes_pod_label_circleId]separator:;regex:(.*)target_label:circle_sourcereplacement:$1action:replace- source_labels:[__meta_kubernetes_pod_label_version]separator:;regex:(.*)target_label:versionreplacement:$1action:replace- source_labels:[__meta_kubernetes_pod_name]separator:;regex:(.*)target_label:pod_namereplacement:$1action:replace- job_name:kubernetes-podskubernetes_sd_configs:- role:podrelabel_configs:- action:keepregex:truesource_labels:- __meta_kubernetes_pod_annotation_pryometheus_io_scrape- action:replaceregex:(.+)source_labels:- __meta_kubernetes_pod_annotation_prometheus_io_pathtarget_label:__metrics_path__- action:replaceregex:([^:]+)(?::\\d+)?;(\\d+)replacement:$1:$2source_labels:- __address__- __meta_kubernetes_pod_annotation_prometheus_io_porttarget_label:__address__ - action:replacesource_labels:- __meta_kubernetes_namespacetarget_label:kubernetes_namespace- action:replacesource_labels:- __meta_kubernetes_pod_label_circleIdtarget_label:circle_source- action:replacesource_labels:- __meta_kubernetes_pod_label_componenttarget_label:destination_component - action:replacesource_labels:- __meta_kubernetes_pod_nametarget_label:kubernetes_pod_name- action:dropregex:Pending|Succeeded|Failedsource_labels:- __meta_kubernetes_pod_phase Change the namespace to the name where your application is deployed.  If you want to know more about Prometheus and Kubernetes service discovery, check out their documentation.  Metadata ‌Each metric has a metadata range that allows a variety of filter and analysis types to be created. More metadata was added to Istio and you can see them described in the table below:\n   Metadata Description Type     destination_component Value on the label ‘app’ of the pod that received the request or unknown if there is no information about it. Text   circle_source Circle label injected into any Kubernetes pods. Text   response_code HTTP status of the response. Numeric    Google Analytics Google Analytics is one of the data sources that Charles can connect to read your metrics.\nTo be able to use it in your metrics group, you will need\n A Google account and the Analytics configured.  If you use the free version of Google Analytics, it will begin collecting metrics data only after a period of 24 hours.  In order for Google Analytics to be able to read and store metrics data, you have to create a Universal Analytics Property.\nCharles uses the Universal Analytics viewId, this is something that Google Analytics 4 no longer supports. When creating a new property be sure to create a Universal Analytics property instead of a GA4 property.\nGoogle Analytics provides a tag to track the data of your application, just insert the tag in your web application for the data to be collected.\nMetadata ‌Each metric has a metadata range that allows a variety of filter and analysis types to be created. More metadata was added to Istio and you can see them described in the table below:\n   Metadata Description Type     circle_source Circle label injected into any Kubernetes pods. Text    If you want to use Charles to analyze your Google Analytics data, you need to add a new metric with your circle ID (renaming it as circle_source) in your metrics label.\nFor more information about it, check out Analytics' documentation  ","excerpt":" Charles' metrics configuration is performed on Istio and on your own …","ref":"/reference/metrics/setting-up-your-metrics/","title":"Setting up your metrics"},{"body":" O grupo de métricas é uma funcionalidade que permite você cadastrar e organizar em grupos qualquer tipo de métrica dentro da sua aplicação. Essas métricas são relacionadas com o provedor que você cadastrou anteriormente.\nComo criar um grupo? Para criar o seu grupo de métricas, siga os passos abaixo:\nPasso 1: Vá até em ‘Circles’ no menu lateral direito e escolha o circulo que você quer criar um novo grupo de métrica;\nPasso 2: Em Add metrics group, digite o nome que desejar para o seu grupo e clique em add group.\nDepois que você criou seu grupo, agora você pode cadastrar a sua métrica:\nPasso 3: Clique em Add metric e coloque o nome da métrica que você deseja;\nPasso 4: Em select a data source, selecione o seu provedor de métrica já cadastrado;\nPasso 5: Clique em Metric e escolha uma métrica e depois disso, utilize o Filter para customizar com o valor e a condicional que você precisa. Esse é o campo onde o seu provedor irá retornar as métricas que já existem.\nVeja o exemplo abaixo:\nPasso 6: Defina um Threshold para estabelecer um limite para sua métrica.\nThreshold são limites predeterminados que você pode configurar no Charles. Ele irá informar quando um deles atingir o valor especificado.\nPor exemplo, se você quiser saber quando sua aplicação atingir um limite de 50 erros, basta customizar o threshold para que você seja informado de quando essa métrica for atingida.\n Pronto! Você cadastrou seu grupo de métricas.  Agora acompanhe o resultado com os gráficos e as informações disponíveis.\nGrupo de Métricas: Advanced Você pode customizar sua própria métrica com a funcão advanced. Essa opção é para usuários que já sabem fazer uma query no Datasource que eles estão utilizando, e também oferece o poder de criar qualquer métrica usando essa ferramenta.\nVeja o exemplo abaixo_,_ mostra onde usar o PromQL para fazer queries no Prometheus, criando um novo tipo de métrica:\n","excerpt":" O grupo de métricas é uma funcionalidade que permite você cadastrar e …","ref":"/pt/refer%C3%AAncia/m%C3%A9tricas/grupo-de-m%C3%A9tricas/","title":"Grupo de métricas"},{"body":" The metrics group is a functionality that allows you to register and organize any kind of metrics in a group inside your application. These metrics are related to the data source you previously registered.\nHow to create? To create your metrics group, follow the next steps:\n **Step 1:** Go to the **\"Circles\"** section, on the left menu and choose the circle you want to create a new metric group; **Step 2:** In **'Add metrics group'**, type the name you want for your group and click on **'Add group'**:  Now you are able to register your metrics**:**\nStep 3: Click on ‘Add metric’ and put the metrics name you want;\nStep 4: Click on ‘Select a Datasource’: select your metrics Datasource already registered;\nStep 5: Click on Metric: Choose one and use the Filter option to customize with the value and the conditional you need. Here is where your Datasource will return the metrics.\nSee the example below:\nStep 6: Define a Threshold to establish a limit to your metric.\nThresholds are predetermined limits that you can configure in Charles. It informs you when one of them reaches the goal.\nFor example, if you want to know if your application hits 50 errors, just customize the threshold and you will be notified when you hit this metric.\n Done! You have registered your metrics group.  Now, you can follow up the result with graphics and the available information, as you can see below:\nMetrics group: Advanced You can customize your own metric with the metrics' group advanced function. This option is for users that already have the knowledge to do queries in the Datasource they are using, it also gives them the power to create any metric possible using that tool.\nCheck out the example below, it shows where to use PromQL to build queries in Prometheus, creating a new metric type:\nTo see more examples of the advanced mode, check out the metrics group to health monitoring section.  ","excerpt":" The metrics group is a functionality that allows you to register and …","ref":"/reference/metrics/metrics-group/","title":"Metrics group"},{"body":" Adding an action After you haveconfigured your action, you have to register it in your metrics group and add it to your circle.\nFollow the next steps below to do that:\nStep 1: Access Metrics group;\nStep 2: Select ‘Add action’ and fill in the fields:\n Type a nickname for action; Select action type: Select the action you have configured before; Action configuration: Configuration to run the chosen plugin.  How does it work? Actions are triggers that will be triggered when all the predetermined thresholds are reached in a metric group.\nMetric groups create metrics you want to track and you can also add actions to this group. When you get to the threshold, the action will be triggered and what is described in your plugin will happen, for example, make deployment of one circle in another circle.\nYou can track the action’s status in the ‘Metrics group’ board, check out below:\n","excerpt":" Adding an action After you haveconfigured your action, you have to …","ref":"/reference/metrics/action/","title":"Action"},{"body":" Como adicionar uma action? Depois de configurar sua action, você deve cadastrá-la no seu grupo de métricas e adicioná-la ao seu círculo.\nSiga os próximo passos para fazer isso:\nPasso 1: Acesse o grupo de métricas;\nPasso 2: Selecione ‘Add action’ e preencha os campos:\n Type a nickname for action: Selecione o nome da sua action; Select action type: Selecione a action que você configurou antes; Action configuration: Configuração de execução do plugin escolhido.  Como funciona? Ações são triggers que serão disparados quando todos os limites (threshold) predeterminados são alcançados em um grupo de métricas.\nO grupo de métricas cria métricas que você deseja acompanhar e você também pode adicionar ações a esse grupo. Quando todos thresholds são alcançados, a ação será disparada e ocorrerá o que está descrito no plugin como, por exemplo, fazer o deploy daquele círculo em um outro círculo.\nVocê pode acompanhar o status da ação no quadro dentro de ‘Grupo de métricas’, veja abaixo:\n","excerpt":" Como adicionar uma action? Depois de configurar sua action, você deve …","ref":"/pt/refer%C3%AAncia/m%C3%A9tricas/a%C3%A7%C3%B5es/","title":"Ações"},{"body":" O que é? Quando sua aplicação já fez o deployment, é uma boa prática checar a saúde, confirmar se o software está funcionando bem ou observar se precisa de algum cuidado específico.\nVocê pode fazer isso com o Charles, utilizando o datasource configurado anteriormente para criar um grupo de métricas especifico que informa o status da sua imagem em que foi feito o deploy.\nVocê encontra abaixo os detalhes.\nRequisitos Para monitorar suas métricas, é preciso ter:\n Datasource configurado e usando o Prometheus Istio 1.7 ou versões mais recentes.  Como monitorar?  Você precisar criar seu grupo de métricas e sua própria métrica, para fazer isso siga os passos na seção métricas; No modo avançado, execute o PromQL queries para monitorar suas métricas.  Para saber mais sobre o PromQL, veja a documentação.  Exemplos de métricas Depois de ter criado o seu grupo de métricas, você também pode criar suas própria métrica. Veja alguns exemplos abaixo.\nQuando você utiliza algum desses exemplos, você pode criar várias métricas, como a proporção de erro pelo total de requisições e você também pode disparar uma ação se essa métrica atingir 10%.  Métrica de latência Aqui, a métrica foi criada para oferecer uma média de latência. Ela divide a duração (em milissegundos) das requisições no último minuto pelo total de requisições no mesmo tempo.\nNo final da query, o valor é multiplicado por 1000 e você consegue ver o resultado em segundos.\nMude o valor de xyz em uma query usando o valor do Circle ID. É válido para todos os exemplos abaixo.  round ( ( sum ( irate ( istio_request_duration_milliseconds_sum{circle_source=\"xyz\"}[1m] ) ) by(destination_component) / sum ( irate ( istio_request_duration_milliseconds_count{circle_source=\"xyz\"}[1m] ) ) by(destination_component) ) * 1000 )  Depois que você instalou o Istio e Prometheus e habilitou o Istio injection em seus pods, o seu Datasource terá as métricas do Istio. Essas métricas podem ser usadas para construir outras mais avançadas. Veja mais sobre essa métrica na documentação do Istio Standard Metrics  Métrica do total de requisições Essa métrica oferece o total de requisições no último minuto:\nceil ( sum ( irate ( istio_requests_total{circle_source=\"xyz\"}[1m] ) ) by(destination_component) ) Métricas de erro de requisição Essa métrica mostra quais as requisições no último minuto, mas apenas para a status de resposta com o código 404:\nceil ( sum ( irate ( istio_requests_total{circle_source=\"xyz\", response_code=\"404\"}[1m] ) ) by(destination_component) )  Você precisa definir um limite (threshold) que preencha o que você precisa monitorar.  ","excerpt":" O que é? Quando sua aplicação já fez o deployment, é uma boa prática …","ref":"/pt/refer%C3%AAncia/m%C3%A9tricas/grupo-de-m%C3%A9tricas-para-monitorar-a-sa%C3%BAde/","title":"Grupo de métricas para monitorar a saúde"},{"body":" What is this? When your application is deployed, it’s a good practice to check its health, confirm if the software is working fine or if it needs special care.\nYou can do this with Charles, using your previously configured metrics datasource to create metric groups that will let you know the status of your deployed image.\nSee more details below.\nRequisites To monitor your metrics you need to have:\n Datasource configured using Prometheus Istio 1.7 or newer versions.  How can you monitor?  You have to create your metrics group and your own metric, to do that follow the steps here; In the advanced mode, execute PromQL queries to monitor your metrics.  To know more about PromQL, check out the documentation.  Metrics Examples After you have created your metric group, you can create your own metrics. Check out below some examples\nWhen you use these examples, you can create lots of metrics, for example, the proportion of errors by total requests and you can trigger an Action if this metric reach 10%.  Latency metric Here, for example, a metric was created to give you the average of the Latency, dividing the duration (in milliseconds) of requests in the last minute by the total of requests in the same time.\nAt the end of the query, the value is multiplied by 1000 and you will get the result in seconds.\nChange the xyz value into your query using the Circle ID value. It’s valid for all examples below.  round ( ( sum ( irate ( istio_request_duration_milliseconds_sum{circle_source=\"xyz\"}[1m] ) ) by(destination_component) / sum ( irate ( istio_request_duration_milliseconds_count{circle_source=\"xyz\"}[1m] ) ) by(destination_component) ) * 1000 )  After you have installed Istio and Prometheus and enabled Istio injection on your pods, your Datasource will have Istio metrics. These metrics can be used to build advanced ones. Check out more about this metric on Istio Standard Metrics documentation.  Total requests metric This metric will give you the total of requests at the last minute:\nceil ( sum ( irate ( istio_requests_total{circle_source=\"xyz\"}[1m] ) ) by(destination_component) ) Error requests metric This metric will give you the requests at the last minute, but only for response status code 404:\nceil ( sum ( irate ( istio_requests_total{circle_source=\"xyz\", response_code=\"404\"}[1m] ) ) by(destination_component) )  Define a threshold that fills what you need to monitor.  ","excerpt":" What is this? When your application is deployed, it’s a good practice …","ref":"/reference/metrics/metric-groups-to-health-monitoring/","title":"Metric groups to health monitoring"},{"body":" Charles offers metrics for you to monitor deploys and circles.\nDeploy metrics Deploy metrics shows a dashboard view with deployment information for you to follow up, such as success or error occurrence numbers and the average implementation time.\nThere is other available information:\n Release name; The chosen circle; Deploy’s date and duration; Responsible for the deployment; Undeploy cases; Modules, components, and used versions; Deploy status: Deployed, Deploying, Error, Undeployed, and Undeploying.  See the example below:\nCircles metrics It is a management feature that helps you view and follow the technical information about your circles.\nThe circle metrics allows you to have an overview of your circles on Charles, like:\n Active and inactive circles; Circle average lifetime; Last update date.  Check out below:\n","excerpt":" Charles offers metrics for you to monitor deploys and circles.\nDeploy …","ref":"/reference/metrics/charles-metrics/","title":"Charles' metrics"},{"body":" O Charles oferece métricas para você monitorar os deploys e os círculos.\nMétrica de deploy A métrica de deploy é uma funcionalidade que permite a visualização de um dashboard com as informações necessárias para você acompanhar os seus deployments, como os números de ocorrências com sucessos ou erros e o tempo médio de implantação.\nHá também outras informações disponíveis, como:\n O nome da release usada; O círculo escolhido; A data e a duração do deploy; O responsável pelo deploy; Casos de undeploy; Módulos, componentes e versões utilizados; Status do deploy: Deployed, Deploying, Error, Undeployed e Undeploying.  Veja o exemplo abaixo:\nMétrica de círculos É um gerenciador que facilita a visualização e o acompanhamento de informações técnicas sobre seus círculos.\nCom as métricas de círculo você pode ter uma visão geral sobre o seus círculos no Charles, como:\n Os círculos ativos e inativos; Tempo de vida do círculo; A data da última atualização;  Veja abaixo:\n","excerpt":" O Charles oferece métricas para você monitorar os deploys e os …","ref":"/pt/refer%C3%AAncia/m%C3%A9tricas/m%C3%A9tricas-do-charles/","title":"Métricas do Charles"},{"body":" Circles Sample Circles Sample é uma aplicação desenvolvida pelo nosso time para que você possa implantá-la em um ambiente de testes e conhecer melhor sobre o conceito de deploy em círculos. Além disso, ela pode ser utilizada para entender como configurar o chart template da sua aplicação.\nPara reproduzir este caso de uso é necessário que você já tenha um workspace definido, para saber mais sobre workspaces, veja a seção de Primeiros Passos.  O caso de uso se baseia nos seguintes passos:\n Cadastro do Circles Sample no Charles; Implantação de uma versão em um círculo; Configuração para acesso ao Circles Sample através do seu cluster de Kubernetes; Teste da aplicação utilizando círculos diferentes.  Cadastrando o Circles Sample nos seus módulos O projeto está disponibilizado no repositório oficial, para fazer o cadastro do módulo, siga as configurações abaixo:\nÉ necessário um passo anterior onde seja feito upload da imagem da aplicação no seu registry cadastrado.  Para acessar o chart template do Circles Sample,acesse o repositório. Caso tenha dúvida sobre essa configuração, veja a referência com o passo-a-passo.\nImplantando uma versão no círculo Default Para implantar o exemplo no círculo default, siga os passos:\n Vá até o menu Circles e marque o filtro Inactive; Selecione o círculo Default; Clique em Insert release e escolha a opção Create Release.  No campo Version name você deve informar o nome completo da release que você deseja utilizar.  Expondo a aplicação Minikube Para acessar a aplicação utilizando o Minikube, execute o minikube tunnel e verifique se o external-ip gerado para o Circles Sample é diferente de 127.0.0.1 (localhost). Neste caso altere seu host conforme o exemplo abaixo:\n#127.0.0.1 localhost \u003cexternal-ip\u003e localhost Cluster Caso a instalação tenha sido feita em outro ambiente garanta que o Circles Sample esteja no mesmo domínio do moove.\nAcessando Circles Sample Acesse http://localhost:8080\nAo acessar a tela do circles sample, você precisa preencher um formulário para que o sample consiga acessar a API do moove e listar os círculos do workspace que você definiu. Veja abaixo como:\n Insert URL Moove: insira a API de acesso ao moove. Authorization: informe o token de acesso a api do moove Bearer access-token. Workspace ID: informe o id do workspace que você deseja acessar.  Essas informações podem ser obtidas no header de alguma requisição como, por exemplo, listagem de círculos, hipóteses, etc. Ou na aba de cookies do browser.  Agora, você pode criar círculos e identificar em qual círculo o usuário vai entrar dado um determinado payload, como nas imagens abaixo:\n","excerpt":" Circles Sample Circles Sample é uma aplicação desenvolvida pelo nosso …","ref":"/pt/guides/caso-de-uso/","title":"Caso de Uso"},{"body":" Circles Sample Circles Sample is developed by our team in order to make you able to implement it in a test environment and to get to know the deploy in circles concept better. Besides, it can be helpful to understand how to configure the chart template of your application,\nTo run this use case, you must already have a defined workspace, to know more about it, check out more on the defining workspace section  The use case is based on the following steps:\n Charles Circles Sample register; A new version implementation in a circle; Configuration to access the Circles Sample through your Kubernetes cluster; Application test using different circles.  Registering Circle Sample in your modules The project is available in the official repository, to register your module, follow the configuration below:\nBefore the steps, it is necessary to make an application image upload in your registered registry.  To access the Circles Sample chart template, access the repository. If you have any doubts about this configuration, check here for a step-by-step reference.\nImplementing a default circle version To implement the default circle example, follow the steps:\n Go to the Circles menu and select the Inactive filter. Select the Default circle; Click on Insert release and choose the Create Release option.  On the Version name field, you have to inform the full name of the release you want to use.  Exposing the application Minikube To access the application using Minikube, run theminikube tunnel and verify if the external-ip generated to the Charles Sample is different from the 127.0.0.1 (localhost). In this case, change your host like the example below:\n#127.0.0.1 localhost \u003cexternal-ip\u003e localhost Cluster In case the installation had been made in another environment, make sure that the Circle Sample is on the same moove domain.\nAccessing Circles Sample Access http://localhost:8080\nWhen accessing the circles' sample screen, you need to fill out a form, so the sample is able to access the moove API to list the workspace circles you have defined. See below how to it:\n Insert URL Moove: insert an API to access a moove. Authorization: inform the access token to the moove API Bearer access-token. Workspace ID: inform the workspace id you want to access.  You can get this information on some request header, for example, circles list, hypothesis, etc. Or in the Cookies tab in the browser.  Now, you are able to create circles and identify in which circles the user will enter given a certain payload, see it on the images below:\n","excerpt":" Circles Sample Circles Sample is developed by our team in order to …","ref":"/guides/use-cases/","title":"Use Cases"},{"body":"","excerpt":"","ref":"/guides/","title":"Guides"},{"body":"","excerpt":"","ref":"/pt/guides/","title":"Guides"},{"body":" What is Charles? CharlesCD is an open-source tool that makes more agile, safe, and continuous deployment, which allows development teams to validate their hypothesis with specific groups of users, simultaneously.\nWhat is circle deploy? The circle deploy is the pioneering concept created by Charles. Thanks to it, it’s possible to deploy the same application with different segmentations of users at the same time.\nWhat is the main difference in Charles? Unlike other ways of deployment, Charles allows developers to perform simultaneous segmentation and agroupment of users with circles.\nWith the tool, the delivery process in traditional environments occurs in longer frequencies - weekly, biweekly, or even monthly - gains a new rhythm. The feedback cycle of your product becomes faster and effective, which means that you can manage your timing in a more intelligent and assertive way. ‌\nBesides, developers will be more encouraged to innovate and to make more implementations of new versions, once that identifying bugs is easier and creating circles helps on minimizing the error budget.\nFor more information about microservices and Charles' modules, check out the platform’s architecture.\n","excerpt":" What is Charles? CharlesCD is an open-source tool that makes more …","ref":"/faq/about-charles/","title":"About Charles"},{"body":" O que é o Charles? O Charles é uma ferramenta open source de continuous deployment que realiza deploys de forma ágil, contínua e segura, permitindo que sejam feitas, de forma simultânea, validações de hipóteses com grupos específicos de usuários.\nO que é deploy em círculos? O deploy em círculos é um conceito pioneiro trazido pelo Charles. Graças a ele, é possível que você realize o deploy de uma mesma aplicação para diferentes segmentações de usuários ao mesmo tempo.\nQual diferencial do Charles? Diferente de outras modalidades de deploy, o Charles possibilita a realização simultânea de segmentações de usuários por meio de círculos.\nUtilizando a ferramenta, o processo de entrega que em ambientes tradicionais ocorre em frequências demoradas - semanal, quinzenal ou até mesmo mensal -, ganha um novo ritmo. O ciclo de feedback do seu produto se torna mais rápido e eficaz e, com isso, você consegue fazer a gestão do timing de forma mais inteligente e assertiva.\nAlém disso, os desenvolvedores são encorajados a inovarem e realizarem várias implantações de novas versões, pois a identificação de bugs ocorre em menos tempo e a criação de círculos auxilia na minimização do error budget.\nPara saber mais sobre a abordagem de microsserviços e os módulos do Charles, veja a arquitetura da plataforma.\n","excerpt":" O que é o Charles? O Charles é uma ferramenta open source de …","ref":"/pt/faq/sobre-o-charles/","title":"Sobre o Charles"},{"body":"","excerpt":"","ref":"/faq/","title":"FAQ"},{"body":"","excerpt":"","ref":"/pt/faq/","title":"FAQ"},{"body":" Circle deploy x Traditional deploy In traditional deploys, it’s common that the application has to pass into different environments until it gets to production. With Charles, the circle deploy system works only in the production environment. The release validation is fragmented according to selected circles, in other words, you can open gradually the access to your release to more and more circles.\nCircle deploy x Blue-green deploys At blue-green deployment, it’s possible to create two identical environments in your infrastructure, but with different versions of an application implemented in each other. In this way, it’s possible to test your hypothesis that, once confirmed, can be migrated from one version to another.\nThe main benefit is that the downtime is zero, which brings more safety for the transition process. Despite this, it represents a higher cost because this deployment demands double of infrastructure to be executed.\nWith Charles, the circle deploy offers to teams more confidence and agility on launching new versions, with zero downtime and no additional costs on infrastructure. Besides, it’s possible to filter, through circles, which users will validate your new application version.\nCircle deploy x Canary release At canary release, it is done the gradual publishing of a software new version from routing within the infrastructure. As soon as the version is tested and it’s more trustworthy, your access is expanded to more users from your base.\nHowever, this technique doesn’t have any strategy for choosing the users during this expansion. For this reason, it becomes more difficult to manage the existing versions of your system, which contributes to not working with many versions, generating limits of possibilities to test hypothesis.\nWith Charles, the circle deployment logic follows a pattern similar to parallel change. That means that, in the platform, you can also start opening the access to a release to a reduced number of users and go gradually expanding as soon as the system passes into tests.\nThe main difference of Charles is that, if you find any error or you have a hypothesis already validated, the reverse is easily done: you can take users off the circle or make deployment of another version with that group or even bring a version of your application to open sea, that is, to all the clients not in a Charle’s circle.\n","excerpt":" Circle deploy x Traditional deploy In traditional deploys, it’s …","ref":"/faq/circle-deploy-vs-other-deploys/","title":"Circle deploy vs Other deploys"},{"body":" Deploy em círculos x Deploy tradicional Nos deploys tradicionais, é comum que a aplicação precise passar por diversos ambientes até chegar à produção. Já com o Charles, o sistema de deploys em círculos funciona somente em um ambiente de produção. A validação por release é fragmentada de acordo com os círculos selecionados, ou seja, você pode ir ampliando gradativamente o acesso à release a mais e mais círculos.\nDeploy em círculos x Blue-green deploys No blue-green deployment, ou implantação azul-verde, são criados dois ambientes idênticos na infraestrutura, porém com diferentes versões de uma aplicação implantados em cada um. Dessa forma, é possível testar suas hipóteses que, uma vez confirmadas, podem migrar de uma versão para outra.\nO principal benefício desta técnica é que o downtime é zero, trazendo mais segurança para a transição. Apesar disso, o custo para o blue-green deployment é bastante elevado, já que demanda o dobro de infraestrutura para ser executado.\nNo caso do Charles, o deploy em círculos oferece ao time mais confiança e rapidez no lançamento de novas versões, com downtime zero e sem custos adicionais de infraestrutura. Além disso, é possível refinar através dos círculos quem serão os usuários que farão a validação da sua nova versão.\nDeploy em círculos x Canary releases No canary release, ou implantação canário, é feita a publicação gradual da nova versão de um software a partir de um roteamento dentro da infraestrutura. À medida em que a versão é testada e se torna mais confiável, seu acesso é expandido a mais usuários da base.\nEntretanto, essa técnica não propõe nenhuma estratégia de escolha de usuários para a expansão. Por esse motivo, torna-se mais difícil gerenciar as versões existentes do sistema, o que contribui para que você não opere com tanto versionamento e, assim, limite suas possibilidades de testar hipóteses.\nNo caso do Charles, a lógica de deploys em círculos segue um padrão parecido de mudança paralela. Isto significa que na plataforma você também começa liberando o acesso à release a um número reduzido de usuários e vai expandindo o acesso à medida que o sistema passa por testes.\nO grande diferencial da plataforma é que, caso algum problema seja encontrado ou a hipótese já tenha sido validada, a reversão é realizada de forma simples: você pode retirar os usuários daquele círculo, realizar o deploy de outra versão para aquele grupo ou levar a versão da aplicação para mar aberto, isto é, para todos os clientes que não estão inseridos em um círculo dentro do Charles.\n","excerpt":" Deploy em círculos x Deploy tradicional Nos deploys tradicionais, é …","ref":"/pt/faq/deploy-em-c%C3%ADrculos-x-outros-deploys/","title":"Deploy em círculos x Outros deploys"},{"body":" Which Charles' repository? We work with monorepo concept on CharlesCD. That means that you can find all of our projects in this public repository.\nDo you want to report an issue or suggest a doc change?  Access our Github repository ZupIT/charlescd; Point out which branch do you want to create your pull request (PR);  It is important that, before you create a PR, just confirm if the request refers to the correct branch: for English documentation is englishdocsand for the Portuguese documentation is v0.2.1.   While you are writing, include the “Docs” label, so we are able to quickly identify that is a request for our documentation.  Your pull request will go through two rounds of review before being published.\nFor more information on how to contribute with Charles, check out our contribution information and policy on Github.\n","excerpt":" Which Charles' repository? We work with monorepo concept on …","ref":"/faq/community/","title":"Community"},{"body":" Qual repositório do Charles? No Charles, trabalhamos com o conceito de monorepo. Logo, você encontra todos os projetos disponíveis neste repositório público.\nQuer reportar alguma issue ou sugerir uma edição na doc?  Acesse nosso repositório no Github ZupIT/charlescd; Indique para qual branch você quer atribuir o seu pull request (PR);  É importante que, antes de abrir o PR, você confirme se a branch está correta. Para documentação em inglês é a englishdocs, enquanto que para a documentação em português é a v0.2.1.   Enquanto estiver escrevendo, inclua a label “Docs” para identificarmos mais rapidamente que se trata de uma solicitação para nossa documentação.  O seu pull request passará por duas rodadas de revisão antes de ser publicada.\nPara saber mais sobre como ajudar com Charles, confira nossas políticas e informações de contribuição no Github.\n","excerpt":" Qual repositório do Charles? No Charles, trabalhamos com o conceito …","ref":"/pt/faq/comunidade/","title":"Comunidade"},{"body":"feature   May 2021 Create CI/CD for staging.\nUpdate helm values.yaml.\nIncrease default timeout time.\nCI Update of charts and changelog.\nUpdate release pipeline.\n    Butler May 2021 Add Butler operator.\nAdd Butler events logs aggregator.\nCharlescd release 1.0.0.\nAdd notification on module deletion.\nAdd undeploy moove notification.\nSort logs by date.\n    UI May 2021 Add clipboard support for HTTP protocol.\nAdd max length validation to input fields.\nUpdate routing when account is clicked.\nShow notification on delete.\nAdd new endpoint to find simplified circle data.\nShow notification on delete a webhook.\nAdd validation isNotBlank for Workspaces' name on creation.\nAdd responsiveness to change password modal.\nAdd margin for subtitle in editing mode.\nAdd minLength to workspace description.\n    GATE May 2021 Add workspace id to authorize request and log deny request.\nAdd System Token.\nAdd notification on module deletion.\nAdd deployment config field.\n    MOOVE May 2021 Charlescd: release 0.7.1.\nAdd deployment active on patch workspace to remove deployment config.\nAdd validation when delete configuration to active deployments.\n    MOOVE April 2021 Add deploy logs. Sync circle matcher information when creating or deleting.\n    UI April 2021 Add Webhook module. Sync circle matcher information when creating or deleting. Add which Charles version.\n    Butler April 2021 Add percentage deployment strategy.\n  fix  UI May 2021 Bump ssri from 6.0.1 to 6.0.2 in /ui.\nFix usergroup modal.\nFix module and components options.\nFix typos and item layout.\nFix namespaced deployment.\nFix workspace refresh menu.\nFix action circle list.\nFix user group permission and create a modal for user group removal.\nFix build error and save action.\nFix UI webhook.\nFix vertical align for InputTitle.\nFix metric action.\nFix defaultValue for Account Profile.\n    Moove May 2021 Auth and token is now nullable.\nFix system token test that was broken by the deployment logs service update.\nImprove moove error message.\nFix matcher csv update.\nHandle template error.\nFix deployment configuration validation on workspace update.\nFix user deletion from user group.\nFix configuration delete validation.\nFix count query.\nFix execution time value.\nFix error message.\nFix usergroup name edit.\nFix semver version from csv validator.\nFix CSV validator version.\nFix matcher update.\nFix workspace status.\n     May 2021 Fix enabling gate configurations at values.yaml.\nFix helm install v1.0.\nFix permissions by workspace query.\nFix cluster role for butler adding access for all API groups.\nFix the pipeline.\nFix update on authorize.\nFix chart.\n    Butler May 2021 Bump y18n from 4.0.0 to 4.0.3 in /butler.\nFix git error.\nChanged token, gatewayName and host value validation.\nFix log endpoint.\nHandle template error.\nHotfix/moove request git token base64.\nFix error when helm url is invalid.\nFix namespace override “deadlock”.\nFix cache error.\nFix lint error and send UNDEPLOY_FAILED by default.\nFix error messages.\nFix usergroup name edit.\n    Moove May 2021 Remove the ‘created’ option the from permission struct.\nFix system token regenerate.\nFix regen system token.\nFix wrong method on policies csv.\n    UI April 2021 Fix [UserGroups] Prevent duplicate list after updates.\nFix button enabled/disabled when creating a new user.\nFix circle creation from CSV file.\n[UserGroups] Permission to Maintainer remove Groups from Workspace.\nFix showing username undefined in the initial screen.\nFix inconsistently displaying the menu after go to root path.\nFix showing required for an optional field when registering a module.\n    Butler April 2021 Change Butler steps on the pipeline.\n    Moove April 2021 Fix getting circle percentage at the repository.\n    Compass April 2021 Fix list metric prometheus error.\n    Hermes April 2021 Fix list metric prometheus error.\n  chore  UI May 2021 UI Operator.\nRemove legacy code and infinite scroll.\nChange UI package manager from yarn to npm.\nChange text in button.\nTest useUpdateName exception.\nImprove text of button in token creation.\nUpdate the user menu after modifying any user.\nDisable button on deploy.\nUpdate user menu by changing the name.\nChange isNotBlank text from ‘No whitespace’ to ‘Cannot start with whitespaces’.\nSet modules branch field as not required.\nUpgrade Wizard.\n    Moove May 2021 Remove unnecessary id from log response.\nDelete deployment configuration.\nEnhancement/duplicated entities.\nUpdate Keycloak version.\nChange logs set to List to garantee order.\nDelete default root user.\nOverrides csv validator dependencies.\n    Gate May 2021 Update policy adding workspace post to management role.\n    Butler May 2021 Validate uppercase tags.\nSetting butler request size limit for 50mb by default.\nBump lodash from 4.17.19 to 4.17.21 in /butler.\n    Villager May 2021 Remove unused villager dependency.\n     May 2021 Update envvar skip SSL.\nUpgrade CI trigger for bug-hunting.\n    UI April 2021 Remove hypotheses feature. Improve advanced options at component screen. Remove actions from module tab when creating it. Upgrade react-scripts from 4.0.1 to 4.0.3. Add Mock Service Worker on UI. Bump node-notifier from 8.0.0 to 8.0.1 in /ui. Bump elliptic from 6.5.3 to 6.5.4 in /ui.\n    Butler April 2021 Butler executions filters.\n  docs   October 2021 Documentation migration from Gitbook to Hugo.\nFix documentation links.\n   Access CharlesCD Release Notes page.\n","excerpt":"feature   May 2021 Create CI/CD for staging.\nUpdate helm values.yaml. …","ref":"/release-notes/","title":"Release Notes"},{"body":"feature   Maio 2021 Criação do CI/CD para staging.\nAtualização do helm values.yaml.\nAumento do tempo de timeout padrão.\nAtualização do CI de charts e changelog.\nAtualização da release do pipeline.\n    Butler Maio 2021 Adição Butler operator.\nAdição de logs de evento do Butler.\nCharlescd release 1.0.0.\nAdição de notificação do módulo de eliminação.\nAdição da notificação de undeploy do Moove.\nClassificação dos registros por data.\nAdicionar Mock Service Worker na IU.\n    UI Maio 2021 Adição do suporte para o protocolo HTTP.\nAdição validação de comprimento máximo para campos de entrada.\nAtualização do routing quando a clicar na conta.\nMostrar a notificação quando apagar.\nAdição do novo serviço para encontrar dados dos círculos simplificados.\nMostrar a notificação quando o webhook é deletado.\nAdição da validação isNotBlank para o nome dos Workspaces criados.\nAdição de responsividade para mudar a senha.\nAdição da margem para legenda no modo de edição.\nAdição minLength para a descrição do workspace.\n    GATE Maio 2021 Adição workspace id para autorizar requisições e negar requisições de log.\nAdição System Token.\nAdição de notificação no módulo de excluir.\nAdição do campo de configuração de deployment.\n    MOOVE Maio 2021 Charlescd: release 0.7.1.\nAdição do patch de deployment ativo para remover a configuração de deployment.\nAdição da validação quando a configuração de deployments estiver ativa.\n    MOOVE Abril 2021 Adição de logs de deploy.\nSincronizar as informações do circle matcher quando criar ou excluir.\n    UI Abril 2021 Adição do módulo Webhook.\nSincronizar as informações do circle matcher quando criar ou excluir.\nAdição de qual versão do Charles você está.\n    Butler Abril 2021 Adição da estrátegia de porcentagem de deployment.\n  fix  UI Maio 2021 Bump ssri da 6.0.1 para 6.0.2 in /ui.\nCorreção do modelo de grupo de usuários.\nCorreção das opções de módulo e componentes.\nCorreção de erros e itens de layout.\nCorreção do deployment de namespaced.\nCorreção da atualização do menu do workspace.\nCorreção das ações na lista dos círculos.\nCorreção da permissão do grupo de usuário e criação de um modal para remoção desse grupo.\nCorreção de erro de build error e como salvar uma ação.\nCorreção UI webhook.\nCorreção do alinhamento vertical para o InputTitle.\nCorreção da ações de métricas.\nCorreção defaultValue para o perfil da conta.\n    Moove Maio 2021 Auth e token agora são anuláveis.\nCorreção do teste do system token que estava quebrado para os logs de deployments e atualização dos serviços.\nMelhoria nas mensagens de erro do moove.\nCorreção da atualização do matcher csv.\nManipulação do erro de template.\nCorreção na configuração de validação do deployment na atualização do workspace.\nCorreção exclusão do usuário do grupo de usuários.\nCorreção validação de exclusão de configuração.\nCorreção da consulta da query.\nCorreção valor do tempo de execução.\nCorreção das mensagens de erro.\nCorreção da edição do nome do grupo de usuários.\nCorreção da versão semver para o validador csv.\nCorreção CSV validador de versão.\nCorreção da atualização do matcher.\nCorreção do status do workspace.\n     Maio 2021 Correção da permissão de configurações do Gate em values.yaml.\nCorreção da instalação v1.0 do Helm.\nCorreção das permissões para query do workspace.\nCorreção do papel do cluster para o Butler, adicionando acesso para todos os grupos de API.\nCorreção da pipeline.\nCorreção na atualização da autorização.\nCorreção do chart.\n    Butler Maio 2021 Bump y18n da 4.0.0 para 4.0.3 in /butler.\nCorreção do erro de git.\nMudança do token, gatewayName e a validação do valor do host.\nCorreção do serviço de log.\nManipular erro de template.\nCorreção da requisição do moove do git token base64.\nCorreção erro quando a URL do Helm é inválida.\nCorreção substituição de namespace “deadlock”.\nCorreção do erro de cache.\nCorreção do erro de lint e o envio do UNDEPLOY_FAILED por padrão.\nCorreção de mensagens de erro.\nCorreção edição do nome do grupo de usuários.\n    Moove Maio 2021 Remoção da opção ‘criado’ da estrutura de permissão.\nCorreção da regeneração do token sistêmico.\nCorreção token sistêmico.\nCorreção método errado nas políticas csv.\n    UI Abril 2021 Correção [Grupo de usuário] para evitar a lista duplicada após atualizações.\nCorreção botão ativado / desativado ao criar um novo usuário.\nCorreção da criação de círculo a partir do arquivo CSV.\n[Grupo de usuário] Permissão para o mantenedor remover grupos de from Workspace.\nCorreção mostrando nome de usuário indefinido na tela inicial.\nCorreção exibição do menu de forma inconsistente para o caminho root.\nCorreção para mostrar ‘obrigatório’ no campo opcional quando registrar um módulo.\n    Butler Abril 2021 Mudança de passos na pipeline do Butler.\n    Moove Abril 2021 Correção para obter a porcentagem do círculo no repositório.\n    Compass Abril 2021 Correção do erro no prometheus na lista de métricas.\n    Hermes Abril 2021 Correção do erro no prometheus na lista de métricas.\n  chore  UI Maio 2021 UI Operator.\nRemoção do código legado e scroll infinito.\nMudança dos pacotes de gerenciamento de UI de yarn para npm.\nMudança de texto em um botão.\nTeste de exceção useUpdateName.\nMelhoria no texto do botão de criação de token.\nAtualização do menu do usuário depois de modificar qualquer usuário.\nDesativar botão de deploy.\nAtualização do menu do usuário alterando o nome.\nMudança do texto isNotBlank de ‘No whitespace’ para ‘Cannot start with whitespaces’.\nDefinir o campo da branch como obrigatório.\nMelhoria do Wizard.\n    Moove Maio 2021 Remoção de id desnecessário do log da resposta.\nExclusão da configuração de deployment.\nMelhoria das entidades duplicadas.\nAtualização da versão do Keycloak.\nAlteração dos registros definidos para garantir ordem.\nExclusão do usuário root padrão.\nSubstituição das dependências do validador csv.\n    Gate Maio 2021 Atualização da política de adição de postagem no workspace para a função de gerenciamento.\n    Butler Maio 2021 Validação das tags em letras maiúsculas.\nConfiguração do limite de tamanho da requisição do Butler para 50mb por padrão.\nBump lodash da 4.17.19 para 4.17.21 no Butler.\n    Villager Maio 2021 Remoção de dependencias não utilizadas do Villager.\n     Maio 2021 Atualização do envvar skip SSL.\nMelhoria do trigger de CI para o bug-hunting.\n    UI Abril 2021 Remoção do recurso de hipóteses.\nMelhorias as opções avançadas na tela do componente.\nRemover ações da guia do módulo ao criá-lo.\nAtualizar os scripts-react de 4.0.1 a 4.0.3.\nBump node-notificador de 8.0.0 para 8.0.1 no /ui.\nBump elíptico de 6.5.3 to 6.5.4 no /ui.\n    Butler Abril 2021 Execução de filtros do Butler.\n  docs   Outubro 2021 Migração da documentação do Gitbook para o Hugo.\n   Acess a página de Release Notes do CharlesCD.\n","excerpt":"feature   Maio 2021 Criação do CI/CD para staging.\nAtualização do helm …","ref":"/pt/release-notes/","title":"Release Notes"},{"body":" The new CharlesCD’s 1.0.0 version brought more reliability in deployments with Operator, however, Helm finds some difficulties to add the necessary elements to Operator in an existing installation, like Custom Resources Definition (CRDs). To change that, you need to follow some steps for a more functional update. See below:\nStep 1: Uninstall CharlesCD (installation with Helm): This step removes everything, including the database. If your database is external or if it is inside Kubernetes, your data won’t be erased, because the volumes persist even after the Helm is uninstalled.  To uninstall, run the following command:\nhelm uninstall -n \u003cNAMESPACE_CHARLESCD\u003e \u003cNOME_DA_INSTALAÇÃO\u003e Step 2: Install CharlesCD using Helm: Now, install CharlesCD via Helm. Use your Values file of the original installation validating for each manifest if there were new values addition.\nYou need to validate making a diff of your installation file and the available in CharlesCD’s repository.  To install, run the command below:\nhelm install -n \u003cNAMESPACE_CHARLESCD\u003e \u003cNOME_DA_INSTALAÇÃO\u003e ./install/helm-chart/ -f ./install/helm-chart/meu-values.yaml Step 3: Update the deployment configuration for each Workspace: After installing, you can access CharlesCD with your admin user. It is necessary to do a new deployment configuration for your workspaces. See how to this configuration in Deployment environment.\nStep 4: Override the release in each active circle: Now, you need to override the release with the latest release where each active circle deployment has been made. See how to perform version overrides in ‘How to create Charles release?’.\nDon’t worry about the override release. CharlesCD will recognize all manifest it needs to take care of.  Step 5: Remove all the manifests where CharlesCD made the deployments before the 1.0.0 version: You need to remove all manifests CharlesCD made deployment before the 1.0.0 version. When deleting these old manifests, the Operator can recreate them, and then your application will work in less than 30 seconds. The unavailability is on average 5 seconds.\nFollow the steps to remove:\n You need to know all existing manifests in the namespace of your workspace that can be deleted. For that, run the following command by workspace:  kubectl api-resources --verbs=list --namespaced -o name | xargs -n 1 kubectl get --show-kind --ignore-not-found -n \u003cNAMESPACE_WORKSPACE\u003e -o go-template --template '{{range .items}}{{.kind}}/{{.metadata.name}} {{.metadata.creationTimestamp}}{{\"\\n\"}}{{end}}' 2\u003e\u00261 | grep -i -v \"Warn\" | grep -i -v \"Deprecat\" | awk '$2 \u003c= \"'$(date -d '1 hour ago' -Ins --utc | sed 's/+0000/Z/')'\" { print $1 }' | grep -i -v \"ConfigMap/istio\" | grep -i -v \"ConfigMap/kube\" | grep -i -v \"Secret/default\" | grep -i -v \"ServiceAccount/default\" This command shows a manifest list related to your workspaces older than 1 hour, which means everything that has not been deployed in the namespace of your Kubernetes. See the example below:\nIf there aren’t applied manifests outside CharlesCD, a Nginx can work as an ingress for your application, for example. Add the command:  | grep -i -v \"PALAVRA_CHAVE\" See how the Nginx example works:\nkubectl api-resources --verbs=list --namespaced -o name | xargs -n 1 kubectl get --show-kind --ignore-not-found -n charlesapp -o go-template --template '{{range .items}}{{.kind}}/{{.metadata.name}} {{.metadata.creationTimestamp}}{{\"\\n\"}}{{end}}' 2\u003e\u00261 | grep -i -v \"Warn\" | grep -i -v \"Deprecat\" | awk '$2 \u003c= \"'$(date -d '1 hour ago' -Ins --utc | sed 's/+0000/Z/')'\" { print $1 }' | grep -i -v \"ConfigMap/istio\" | grep -i -v \"ConfigMap/kube\" | grep -i -v \"Secret/default\" | grep -i -v \"ServiceAccount/default\" | grep -i -v \"nginx\" This command removes the manifests list and after you will the complete list to remove the cluster.\nWhen you have this manifests list, delete all the manifests and the rest will be executed by the Operator. Run the command below:  kubectl delete -n \u003cnamespace\u003e \u003cmanifesto\u003e  Done! The update process is complete :)  ","excerpt":" The new CharlesCD’s 1.0.0 version brought more reliability in …","ref":"/migration-from-0.7.1-version-to-1.0.0/","title":"Migration from 0.7.1 version to 1.0.0"},{"body":" A nova versão 1.0.0 do CharlesCD trouxe mais confiabilidade nos deploys com o Operator, porém o Helm encontra dificuldades para adicionar elementos necessários ao Operator em uma instalação já existente, como o Custom Resources Definition (CRDs). Por isso, você precisa seguir alguns passos para uma atualização mais funcional. Veja abaixo:\nPasso 1: Desinstale o CharlesCD (instalação feita com o Helm): Este passo remove tudo, inclusive o banco de dados. Se seu banco de dados é externo ou se está dentro do Kubernetes, seus dados não serão apagados, porque os volumes persistem mesmo após uma desinstalação via Helm.  Para desinstalar, execute o seguinte comando:\nhelm uninstall -n \u003cNAMESPACE_CHARLESCD\u003e \u003cNOME_DA_INSTALAÇÃO\u003e Passo 2: Instale o CharlesCD utilizando o Helm: Agora instale o CharlesCD via Helm. Utilize o seu arquivo de Values da instalação original validando para cada manifesto se houve a adição de novos valores.\nVocê precisa validar fazendo um diff do seu arquivo de instalação e do disponível no repositório do CharlesCD.  Para instalar, execute o comando abaixo:\nhelm install -n \u003cNAMESPACE_CHARLESCD\u003e \u003cNOME_DA_INSTALAÇÃO\u003e ./install/helm-chart/ -f ./install/helm-chart/meu-values.yaml Passo 3: Atualize a configuração de Deployment para cada Workspace: Depois de instalar, você poderá acessar o CharlesCD com seu usuário administrador da plataforma É necessário fazer uma nova configuração de deployment para seus workspaces. Veja como fazer essa configuração em Configuração de Deployment.\nPasso 4: Faça o override de release em cada círculo ativo Agora, você precisa fazer o Override de Release com a última release em que o deployment em cada círculo ativo foi feito. Veja como realizar overrides de versões em ‘Como criar releases pelo Charles?’.\nNão se preocupe com o override de release. O CharlesCD irá reconhecer todos os manifestos que ele precisa tomar conta.  Passo 5: Remova todos os manifestos em que o CharlesCD fez os deployments antes da versão 1.0.0: Você precisa remover todos os manifestos em que o CharlesCD fez os deployments antes da versão 1.0.0. Ao deletar esse esses manifestos antigos, o Operator pode recriá-los e com isso, a sua aplicação vai funcionar em menos de 30 segundos. A indisponibilidade é em média de 5 segundos.\nSiga os passos para remoção:\n Você precisa saber todos os manifestos existentes no namespace do seu workspace que podem ser deletados. Para isso execute o seguinte comando, por worspace:  kubectl api-resources --verbs=list --namespaced -o name | xargs -n 1 kubectl get --show-kind --ignore-not-found -n \u003cNAMESPACE_WORKSPACE\u003e -o go-template --template '{{range .items}}{{.kind}}/{{.metadata.name}} {{.metadata.creationTimestamp}}{{\"\\n\"}}{{end}}' 2\u003e\u00261 | grep -i -v \"Warn\" | grep -i -v \"Deprecat\" | awk '$2 \u003c= \"'$(date -d '1 hour ago' -Ins --utc | sed 's/+0000/Z/')'\" { print $1 }' | grep -i -v \"ConfigMap/istio\" | grep -i -v \"ConfigMap/kube\" | grep -i -v \"Secret/default\" | grep -i -v \"ServiceAccount/default\" Este comando mostra uma lista de manifestos relacionados ao seu workspace mais antigo que 1 hora, isto é, tudo que não houve o deployment no namespace de seu Kubernetes. Veja abaixo um exemplo:\nSe não existir manifestos aplicados por fora do CharlesCD, um nginx para servir de ingress para sua aplicação, por exemplo. Adicione no comando:  | grep -i -v \"PALAVRA_CHAVE\" Veja como é exemplo do nginx:\nkubectl api-resources --verbs=list --namespaced -o name | xargs -n 1 kubectl get --show-kind --ignore-not-found -n charlesapp -o go-template --template '{{range .items}}{{.kind}}/{{.metadata.name}} {{.metadata.creationTimestamp}}{{\"\\n\"}}{{end}}' 2\u003e\u00261 | grep -i -v \"Warn\" | grep -i -v \"Deprecat\" | awk '$2 \u003c= \"'$(date -d '1 hour ago' -Ins --utc | sed 's/+0000/Z/')'\" { print $1 }' | grep -i -v \"ConfigMap/istio\" | grep -i -v \"ConfigMap/kube\" | grep -i -v \"Secret/default\" | grep -i -v \"ServiceAccount/default\" | grep -i -v \"nginx\" Esse comando remove da listagem o manifesto e depois você terá a lista completa para remoção do cluster.\nQuando você estiver com essa lista de manifestos, delete os manifestos e o restante será executado pelo Operator. Execute o comando abaixo:  kubectl delete -n \u003cnamespace\u003e \u003cmanifesto\u003e  Pronto! O processo de atualização foi finalizado :)  ","excerpt":" A nova versão 1.0.0 do CharlesCD trouxe mais confiabilidade nos …","ref":"/pt/migra%C3%A7%C3%A3o-da-vers%C3%A3o-0.7.1-para-1.0.0/","title":"Migração da versão 0.7.1 para 1.0.0"}]